<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>自习室 on LeeReindeer&#39;s blog</title>
    <link>https://leer.moe/categories/%E8%87%AA%E4%B9%A0%E5%AE%A4/</link>
    <description>Recent content in 自习室 on LeeReindeer&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 19 May 2020 18:36:15 +0800</lastBuildDate>
    
	<atom:link href="https://leer.moe/categories/%E8%87%AA%E4%B9%A0%E5%AE%A4/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MapReduce 6.824</title>
      <link>https://leer.moe/2020/05/19/6.824_mapreduce/</link>
      <pubDate>Tue, 19 May 2020 18:36:15 +0800</pubDate>
      
      <guid>https://leer.moe/2020/05/19/6.824_mapreduce/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;MapReduce Framework: Users define &lt;em&gt;map&lt;/em&gt; function that processes a key/value pair to generate a set of intermediate k/v pairs; A &lt;em&gt;reduce&lt;/em&gt; function that merge all intermediate k/v pairs associated with the same intermediate key.&lt;/p&gt;
&lt;p&gt;MapReduce Framework &lt;strong&gt;hides&lt;/strong&gt; the messy details of parallelization, fault-tolerance, data distribution and load balancing in a library.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>AbstractQueuedSynchronizer</title>
      <link>https://leer.moe/2019/04/25/java-concurrent-aqs/</link>
      <pubDate>Thu, 25 Apr 2019 19:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/04/25/java-concurrent-aqs/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;AQS 是用来构建锁和同步工具的基本框架。本文主要基于 AQS 作者 Doug Lea 的论文*&lt;a href=&#34;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&#34;&gt;The java.util.concurrent Synchronizer Framework&lt;/a&gt;* 和 JDK 1.8 的文档。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leer.moe/2019/01/06/java-concurrent-toc/&#34;&gt;Java并发-目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>K-th 问题</title>
      <link>https://leer.moe/2019/04/17/k-th/</link>
      <pubDate>Wed, 17 Apr 2019 19:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/04/17/k-th/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在面试的时候碰到的问题，总结一下。这类问题有以下几种形式，但本质上是一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求第 k 个最大的数&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/lalor/article/details/7368438&#34;&gt;从一亿个数里找出最大的一百个&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中位数，即第 n / 2 最大的数&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来以第一个问题的形式来分析和编码，即 &amp;ldquo;求第 k 个最大的数&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>数据结构-二叉树</title>
      <link>https://leer.moe/2019/03/18/binary-tree/</link>
      <pubDate>Mon, 18 Mar 2019 15:49:47 +0000</pubDate>
      
      <guid>https://leer.moe/2019/03/18/binary-tree/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二叉树的&lt;strong&gt;第 i 层最多有$2^{i-1}$个节点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;深度为 h 的二叉树最多有$2^h - 1$个节点&lt;/strong&gt;。定义根节点深度为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n_0$(度为 0 的节点，叶子节点)，$n_1$（度为 1 的节点），$n_2$（度为 2 的节点），有 $n_0 = n_2 + 1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;n0+n1+n2-1 = 0*n0+1*n1+2*n2

n0 = n2+1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>单线程和多线程下的ConcurrentModificationException</title>
      <link>https://leer.moe/2019/03/11/concurrentmodificationexception/</link>
      <pubDate>Mon, 11 Mar 2019 22:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/03/11/concurrentmodificationexception/</guid>
      <description>这个寒假看的《Java并发编程实战》终于派上了用场，今天搬砖过程中遇到了ConcurrentModificationException，结果</description>
    </item>
    
    <item>
      <title>JPA、Hibernate、Spring Data JPA 傻傻分不清？</title>
      <link>https://leer.moe/2019/03/09/jpa-hibernate-spring-data-jpa/</link>
      <pubDate>Sat, 09 Mar 2019 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/03/09/jpa-hibernate-spring-data-jpa/</guid>
      <description>JPA、Hibernate、Spring Data JPA 三者的联系和不同: Hibernate is a JPA implementation, while Spring Data JPA is a JPA Data Access Abstraction. With Spring Data, you may use Hibernate, Eclipse Link or any other JPA provider. 上面这张关系图展示了</description>
    </item>
    
    <item>
      <title>Java并发-Synchronized和Reentrantlock</title>
      <link>https://leer.moe/2019/01/07/java-concurrent-synchronized-reentrantlock/</link>
      <pubDate>Mon, 07 Jan 2019 10:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/01/07/java-concurrent-synchronized-reentrantlock/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Java中对线程的同步和互斥有两种方式：使用&lt;code&gt;synchronized&lt;/code&gt;关键字和使用&lt;code&gt;ReentranLock&lt;/code&gt; 。也有其他的实现比如信号量，在操作系统里也有学到。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leer.moe/2019/01/06/java-concurrent-toc/&#34;&gt;Java并发-目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Java并发-目录</title>
      <link>https://leer.moe/2019/01/06/java-concurrent-toc/</link>
      <pubDate>Sun, 06 Jan 2019 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/01/06/java-concurrent-toc/</guid>
      <description>Java 并发编程笔记目录 synchronized 和 ReentrantLock AQS volatile 关键字 单线程和多线程下的ConcurrentModificationExceptio &amp;hellip;</description>
    </item>
    
    <item>
      <title>firewall-cmd 常用命令</title>
      <link>https://leer.moe/2019/01/03/firewall/</link>
      <pubDate>Thu, 03 Jan 2019 10:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/01/03/firewall/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在换 ss 端口的时候，发生一件神奇的事。我发现那台 VPS 只能使用2019端口，改成其他的都不行。最后（在用 &lt;code&gt;CTRL-R&lt;/code&gt; 翻以前用过的命令时，不知怎么出现&lt;code&gt;firewall-cmd&lt;/code&gt;的提示:joy:，太灵性了，不然我也想不到），我才意识到是我自己使用&lt;code&gt;firewall-cmd&lt;/code&gt;加了端口访问限制。好蠢。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>操作系统-复习提纲</title>
      <link>https://leer.moe/2019/01/02/os-review-map/</link>
      <pubDate>Wed, 02 Jan 2019 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/01/02/os-review-map/</guid>
      <description></description>
    </item>
    
    <item>
      <title>操作系统-银行家算法</title>
      <link>https://leer.moe/2019/01/01/os-banker-algorithm/</link>
      <pubDate>Tue, 01 Jan 2019 19:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/01/01/os-banker-algorithm/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇笔记主要介绍&lt;strong&gt;死锁避免中的银行家算法&lt;/strong&gt;的实现。同样是参考书上的例子和使用&lt;a href=&#34;https://gist.github.com/LeeReindeer/a0a78d29d2940dd5a958da67f0db30e8&#34;&gt;C++实现&lt;/a&gt;的。作为新年的第一篇文章:tada:，我也尝试了一些新鲜的东西，比如Markdown中数学公式，同时为算法找了两个测试用例进行测试。&lt;/p&gt;
&lt;p&gt;写文章耗时：1 hour&lt;/p&gt;
&lt;p&gt;编码：1 hour&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>操作系统-电梯调度算法</title>
      <link>https://leer.moe/2018/12/28/os-elevator-algorithm/</link>
      <pubDate>Fri, 28 Dec 2018 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/28/os-elevator-algorithm/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近在复习操作系统，老师不讲设备管理这一部分，让我们自学，期末要考&lt;strong&gt;电梯调度算法&lt;/strong&gt;。这篇文章分别用自然语言，流程图，&lt;a href=&#34;https://gist.github.com/LeeReindeer/95efbc79b18636236dca4625bb5b83d5&#34;&gt;C++语言&lt;/a&gt;来描述电梯算法，其实电梯算法真的很简单:smile_cat:&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Java基础-Pass by value</title>
      <link>https://leer.moe/2018/12/20/java-fun-pass-by-value/</link>
      <pubDate>Thu, 20 Dec 2018 16:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/20/java-fun-pass-by-value/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Java的方法参数是按值传递的，这篇主要是把Java的传值机制和C语言的指针和二重指针进行比较，并基于汇编代码更深入的理解传值和传引用。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>数据结构-Treap</title>
      <link>https://leer.moe/2018/12/17/data-structrue-treap/</link>
      <pubDate>Mon, 17 Dec 2018 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/17/data-structrue-treap/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;今天的算法课上，老师讲了一个比较有意思的数据结构：&lt;code&gt;Treap&lt;/code&gt;。它的名字就比较有意思，为什么叫&lt;code&gt;Treap&lt;/code&gt;呢？是Tree + Heap两个单词的结合，所以这个数据结构也就是二叉树和二叉堆的结合了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Treap也是平衡二叉搜索树的一种。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Balanced Binary Search Tree 也可以简称为 Balanced Search Tree，为了方便区分我下面会简称为&lt;code&gt;BBST&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Java基础-ArrayList和LinkedList</title>
      <link>https://leer.moe/2018/12/17/java-fun-arraylist-linkedlist/</link>
      <pubDate>Mon, 17 Dec 2018 15:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/17/java-fun-arraylist-linkedlist/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;相对与&lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;LinkedList&lt;/code&gt;都算比较简单的数据结构，通过这篇文章分别的了解一下它们。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Java基础-HashMap源码简析</title>
      <link>https://leer.moe/2018/12/16/java-fun-hashmap/</link>
      <pubDate>Sun, 16 Dec 2018 12:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/16/java-fun-hashmap/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;基于&lt;code&gt;HashMap&lt;/code&gt;JDK1.8中的源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考前辈们的成果，简单的分析&lt;code&gt;HashMap&lt;/code&gt;的源码，了解一下&lt;code&gt;HashMap&lt;/code&gt;的存储结构，主要方法工作原理和线程安全这几个方面。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础-Object的11个方法</title>
      <link>https://leer.moe/2018/12/14/java-fun-object-method/</link>
      <pubDate>Fri, 14 Dec 2018 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/14/java-fun-object-method/</guid>
      <description>&lt;p&gt;一切从对象开始。在Java中Object类是是所有类的父类，也是根类。它一共有11个方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础-目录</title>
      <link>https://leer.moe/2018/12/12/java-fun-toc/</link>
      <pubDate>Wed, 12 Dec 2018 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/12/java-fun-toc/</guid>
      <description>接下来应该会写一系列Java基础的笔记吧，之前虽觉得自己已经熟悉Java，但都没有系统的做笔记和整理，而且Java也是自学的，很多知识都没有</description>
    </item>
    
    <item>
      <title>CSAPP Data Lab 思路和笔记</title>
      <link>https://leer.moe/2018/11/26/csapp_data_lab/</link>
      <pubDate>Mon, 26 Nov 2018 15:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/11/26/csapp_data_lab/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://csapp.cs.cmu.edu/3e/labs.html&#34;&gt;Data Lab&lt;/a&gt;&lt;em&gt;[Updated 11/2/18]&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;11/2/18 新鲜出炉的 Data Lab，不同时期的 lab 内容会不一样。&lt;/p&gt;
&lt;p&gt;肝了两天还是没有全部做出来，之前很以为很简单呢（&lt;/p&gt;
&lt;p&gt;最近也终于买了 CS:APP3e 英文版，配合 CMU 的&lt;a href=&#34;https://www.bilibili.com/video/av20304787&#34;&gt;课程视频&lt;/a&gt;食用更佳。顺便可以练习英语听力和阅读，阅读已经可以流畅了，这种英文书基本看得懂，但是听力就不行（&lt;/p&gt;
&lt;p&gt;解题的思路一般会写在注释里的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;bitxor&#34;&gt;bitXor&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;/*s
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt; * bitXor - x^y using only ~ and &amp;amp;
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt; *   Example: bitXor(4, 5) = 1
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt; *   Legal ops: ~ &amp;amp;
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt; *   Max ops: 14
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt; *   Rating: 1
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;bitXor&lt;/span&gt;(&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; y) {
  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// 德摩根定律
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// a xor b = (~a | ~b) &amp;amp; (a | b)
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// = ~(a &amp;amp; b) &amp;amp; ~(~a &amp;amp; ~b)
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;x &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;y) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;~&lt;/span&gt;(x &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; y);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然这题比较简单，但我还是想了好久。主要是我把这个德摩根定律忘得差不多了，记得在离散数学里讲过。&lt;/p&gt;
&lt;p&gt;利用的性质主要是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a ^ b = (~a | ~b) &amp;amp; (a | b)&lt;/li&gt;
&lt;li&gt;(~a | ~b) = ~(a &amp;amp; b)&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Spring Boot项目部署之开启HTTPS</title>
      <link>https://leer.moe/2018/11/16/springboot-https/</link>
      <pubDate>Fri, 16 Nov 2018 20:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/11/16/springboot-https/</guid>
      <description>迫于课设，完成了对 LightBlog 的重构，使用 Spring Boot 和 SSM 框架，今晚突然想要支持一下 HTTPS（小绿锁）。 差不多折腾了一小时，现在使用的是下面这种方案（又不是</description>
    </item>
    
    <item>
      <title>【Android 基础】学习计划</title>
      <link>https://leer.moe/2018/11/12/android_fundamental_toc/</link>
      <pubDate>Mon, 12 Nov 2018 14:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/11/12/android_fundamental_toc/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;准备春招，重温 Android&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一篇接下来的学习计划，使用的教程是&lt;a href=&#34;https://developer.android.com/courses/fundamentals-training/toc-v2#top_of_page&#34;&gt;Google Training courses&lt;/a&gt;。基本上是按着 CodeLab 一步一步做下来，CodeLab 里用的是 Java，我用的 Kotlin 。会对期间遇到问题和编程方法进行总结，发布在 &lt;a href=&#34;https://blog.csdn.net/lreindeer363&#34;&gt;CSDN&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【Spring 揭秘（二）】Spring AOP</title>
      <link>https://leer.moe/2018/11/10/spring_aop/</link>
      <pubDate>Sat, 10 Nov 2018 15:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/11/10/spring_aop/</guid>
      <description>&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;
&lt;p&gt;术语不是为了限制你的设计，而是借此可以更方便的讨论和思考这个问题。这是我早上在《游戏设计要则探秘》上看的一句话，当然术语也不能华而不实，最好做到顾名思义或指出本质。&lt;/p&gt;
&lt;p&gt;在使用 AOP 之前，我们需要了解AOP涉及的相关概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JoinPint：AOP的功能模块要植入到OOP的模块中，需要知道在哪些执行点上进行植入，这些执行点就是JoinPoint。JoinPoint可以是方法的调用，字段设置，异常处理执行等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PointCut：PointCut是对JoinPoint的表现形式，可以直接用方法名，正则表达式还有特定的PointCut表述语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Advice：Advice就是横切点功能的载体。包括，Before Advice，AAfter Advice，Around Advice。这三个切入的时间不同，可顾名思义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Aspect：Aspect可以理解为切面，它可以包含多个PointCut和Advice。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>【Spring 揭秘（一）】Spring Bean DI and Instantiating</title>
      <link>https://leer.moe/2018/11/10/spring_bean/</link>
      <pubDate>Sat, 10 Nov 2018 14:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/11/10/spring_bean/</guid>
      <description>&lt;h2 id=&#34;cheatsheet&#34;&gt;cheatsheet&lt;/h2&gt;
&lt;p&gt;如果你赶时间，可以只看这一节的内容。&lt;/p&gt;
&lt;h3 id=&#34;bean-的实例化方式&#34;&gt;bean 的实例化方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XML 配置时
&lt;ul&gt;
&lt;li&gt;工厂方法&lt;/li&gt;
&lt;li&gt;静态工厂&lt;/li&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注解方式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于注解方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@Component：可以用于注册所有bean&lt;/li&gt;
&lt;li&gt;@Repository：主要用于注册dao层的bean&lt;/li&gt;
&lt;li&gt;@Controller：主要用于注册控制层的bean&lt;/li&gt;
&lt;li&gt;@Service：主要用于注册服务层的bean&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;spring-bean-的注入方式&#34;&gt;Spring bean 的注入方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XML配置
&lt;ul&gt;
&lt;li&gt;setter 方法注入&lt;/li&gt;
&lt;li&gt;构造函数注入&lt;/li&gt;
&lt;li&gt;工厂方法/静态工厂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注解方式注入（&lt;code&gt;@AutoWired&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Map DateTime to Java Date in MyBatis</title>
      <link>https://leer.moe/2018/11/07/mybatis_datetime/</link>
      <pubDate>Wed, 07 Nov 2018 10:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/11/07/mybatis_datetime/</guid>
      <description>问题 最近在用 Spring Boot 重写 LightBlog，查询到的博客的 Date 属性的日期正常，但是时间始终为 00:00:00。 resultMap 映射如下： &amp;lt;resultMap id=&amp;#34;blogMap&amp;#34; type=&amp;#34;Blog&amp;#34;&amp;gt; &amp;lt;id property=&amp;#34;blogId&amp;#34; column=&amp;#34;blog_id&amp;#34;/&amp;gt; &amp;lt;result property=&amp;#34;blogUid&amp;#34; column=&amp;#34;blog_uid&amp;#34;/&amp;gt; &amp;lt;result property=&amp;#34;blogTagId&amp;#34; column=&amp;#34;blog_tag_id&amp;#34;/&amp;gt;</description>
    </item>
    
    <item>
      <title>Concurrent with Semaphore</title>
      <link>https://leer.moe/2018/10/18/semaphore/</link>
      <pubDate>Thu, 18 Oct 2018 16:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/10/18/semaphore/</guid>
      <description>&lt;h2 id=&#34;semaphore&#34;&gt;Semaphore&lt;/h2&gt;
&lt;p&gt;Dijkstra 大佬提出了一种解决不同线程之前同步和互斥问题的方法。这种方法就是 PV 操作，它基于 Semaphore（信号量）。&lt;/p&gt;
&lt;p&gt;可以把信号量简单看成一个非负整数，只能使用两种操作来改变它的值，这两种操作就是 P 和 V，用伪代码描述如下（与教材《操作系统教程》上不同，这里的&lt;a href=&#34;https://stackoverflow.com/questions/20656295/what-is-general-semaphores-range&#34;&gt;信号量不能为负值&lt;/a&gt;）。PV 操作的伪代码实现如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;P(s)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;P(s) {
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (p &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;) {
     s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;--&lt;/span&gt;;
    } &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;else&lt;/span&gt; {
     append this &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;thread&lt;/span&gt; to list;
     sleep();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;V(s)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;V(s) {
    s&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;++&lt;/span&gt;;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (list is no empty) {
        list.pop().wakeup();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P 和 V 的执行过程都是不可打断的，并且 P 和 V 要成对的出现。这样就保证了程序不可能进入信号量为负值的状态，可以利用这个特性实现进程之间的互斥和同步。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>6.828 Homework 2:Shell</title>
      <link>https://leer.moe/2018/09/29/6.828_hw2_shell/</link>
      <pubDate>Sat, 29 Sep 2018 16:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/09/29/6.828_hw2_shell/</guid>
      <description>&lt;p&gt;这次的作业是实现一个简单的 shell。通过阅读 &lt;a href=&#34;https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf&#34;&gt;xv6 book&lt;/a&gt; 的第零章，基本上就可以实现题目中所说的三个功能，也是shell的基本功能：运行简单的命令，输入输出重定向，管道。&lt;/p&gt;
&lt;p&gt;题目提供的&lt;code&gt;sh.c&lt;/code&gt;已经实现了命令的解析（大概看了一下流程，大概就是个递归下降解释器吧，这次作业无需关心这个），只需要完成&lt;code&gt;runcmd&lt;/code&gt;函数中缺少的代码即可。&lt;/p&gt;
&lt;h2 id=&#34;流程&#34;&gt;流程&lt;/h2&gt;
&lt;p&gt;先从 &lt;code&gt;main&lt;/code&gt; 函数看起：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt;) {
  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#099&#34;&gt;100&lt;/span&gt;];
  &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; fd, r;

  &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Read and run input commands.
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;while&lt;/span&gt; (getcmd(buf, &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(buf)) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;) {
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (buf[&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#39;c&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; buf[&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#39;d&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; buf[&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#d14&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;) {
      &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Clumsy but will have to do for now.
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// Chdir has no effect on the parent if run in the child.
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;      buf[strlen(buf) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;// chop \n
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (chdir(buf &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;)
        fprintf(stderr, &lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;cannot cd %s&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;&lt;/span&gt;, buf &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;);
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;if&lt;/span&gt; (fork1() &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;)
      runcmd(parsecmd(buf));
    wait(&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;r);
  }
  exit(&lt;span style=&#34;color:#099&#34;&gt;0&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 函数循环调用 &lt;code&gt;getcmd&lt;/code&gt;从 console 读取命令，对 &lt;code&gt;cd &lt;/code&gt;命令做了特别处理。之后&lt;code&gt;fork&lt;/code&gt;创建子进程，调用&lt;code&gt;parsecmd&lt;/code&gt;解析命令，再调用&lt;code&gt;runcmd&lt;/code&gt;执行得到的命令。最后调用&lt;code&gt;wait&lt;/code&gt;等待子进程结束。&lt;code&gt;main&lt;/code&gt; 的基本流程就这样。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JavaFX与Kotlin的Main函数</title>
      <link>https://leer.moe/2018/08/02/javafx_main_kotlin/</link>
      <pubDate>Thu, 02 Aug 2018 20:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/08/02/javafx_main_kotlin/</guid>
      <description>&lt;p&gt;晚上想做个小应用，不想用 丑陋的&lt;code&gt;swing&lt;/code&gt;（确信）。于是试了试&lt;code&gt;JavaFX&lt;/code&gt;。MVC 模式，XML 和 &lt;code&gt;Scene Builder&lt;/code&gt;  设计 UI，设计出的 UI 颜值还高。这样一看还是比较熟悉的嘛，好像和 Android 的套路差不多。&lt;/p&gt;
&lt;p&gt;当然还是要用&lt;code&gt;Kotlin&lt;/code&gt;。不过在写&lt;code&gt;Main&lt;/code&gt;函数的时候就遇到问题了，简直气炸（&lt;/p&gt;
&lt;h2 id=&#34;三次尝试&#34;&gt;三次尝试&lt;/h2&gt;
&lt;h3 id=&#34;一&#34;&gt;一&lt;/h3&gt;
&lt;p&gt;首先，在 Java 里的代码应该是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Main&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;extends&lt;/span&gt; Application &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//...
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;String&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; args&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        launch&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;args&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;没有任何问题。&lt;/p&gt;
&lt;p&gt;那么在 Kotlin 中，我首先想到的是 &lt;code&gt;Top level&lt;/code&gt; 的 Main 函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#900;font-weight:bold&#34;&gt;main&lt;/span&gt;(args: Array&amp;lt;String&amp;gt;) = Application.launch(*args)

&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;Main&lt;/span&gt; : Application() {
	&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//...
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Android 四大组件：Activity</title>
      <link>https://leer.moe/2018/05/16/android-activity/</link>
      <pubDate>Wed, 16 May 2018 07:30:00 +0000</pubDate>
      
      <guid>https://leer.moe/2018/05/16/android-activity/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;https://developer.android.com/guide/components/activities&#34;&gt;Google 官方教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;activity-是什么&#34;&gt;Activity 是什么&lt;/h2&gt;
&lt;p&gt;Activity 是四大组件之一，每个 Activity 有一个视图，是和用户交互的地方。一个 App 可以有零到多个 Activity，&lt;strong&gt;每个 Activity 都必须在 &lt;code&gt;AndroidManifest.xml&lt;/code&gt; 清单文件中声明。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C语言-可怕的指针</title>
      <link>https://leer.moe/2018/03/28/pointer_in_c/</link>
      <pubDate>Wed, 28 Mar 2018 07:30:00 +0000</pubDate>
      
      <guid>https://leer.moe/2018/03/28/pointer_in_c/</guid>
      <description>&lt;h2 id=&#34;一重指针&#34;&gt;一重指针&lt;/h2&gt;
&lt;h3 id=&#34;简单使用&#34;&gt;简单使用&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;a; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//defines an pointer to a, the address where a store.
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;printf(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, a);
printf(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;p); &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//here * is poiner operator, get the value of address = a.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;数组指针&#34;&gt;数组指针&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组名代表数组的&lt;strong&gt;首地址&lt;/strong&gt;，二维数组名则是&lt;strong&gt;行地址&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一维数组&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; a[&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;};
 &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;p1 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; a;
 printf(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, a[&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;]); &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//2
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt; printf(&lt;span style=&#34;color:#d14&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*++&lt;/span&gt;p1)); &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二维（多维）数组&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; b[&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;][&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; {{&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;3&lt;/span&gt; ,&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;},{&lt;span style=&#34;color:#099&#34;&gt;5.&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#099&#34;&gt;8&lt;/span&gt;}};
 &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;p2)[&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; b; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//**A pointer** to a array of 4 integers,行地址
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#458;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;p3)[&lt;span style=&#34;color:#099&#34;&gt;2&lt;/span&gt;][&lt;span style=&#34;color:#099&#34;&gt;4&lt;/span&gt;] &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;b; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//**A pointer** to 2d array
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt; b[&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;];&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//5
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;((&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;p2 &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//5,(*p + 1) == 一维数组b[1]的首地址
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt; p2[&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//5
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt; (&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;*&lt;/span&gt;p2)[&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#099&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#998;font-style:italic&#34;&gt;//5
&lt;/span&gt;&lt;span style=&#34;color:#998;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Read source code of Javac-1</title>
      <link>https://leer.moe/2017/10/21/read_javac_1/</link>
      <pubDate>Sat, 21 Oct 2017 18:46:18 +0000</pubDate>
      
      <guid>https://leer.moe/2017/10/21/read_javac_1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近发生太多不愉快的事, 还是看看源码压压惊(.这篇大概有很多错误.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-说在前面&#34;&gt;1. 说在前面&lt;/h2&gt;
&lt;p&gt;Javac 大家(只是习惯用大家)应该用的很熟悉了.想我第一次接触 java 就是从 Javac 编译第一个程序的.到了今天,我时不时也会想这到底是怎么实现的?这个想法一直挥之不去.咦,跑题了(.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;代码编译的结果是从本地机器码转变成字节码,是存储格式发展的一小步,却是编程语言发展的一大步.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话反复出现在《深入理解Java虚拟机》里.我倒是没有体会到什么发展,也可以理解为这是为了跨平台而做出的牺牲,虚拟机也为此出现.当然也有直接把 Java 源代码编译成机器码的编译器( AOT 编译器).先不管这个,从 Java 源代码到字节码到底经历了什么呢?肯定要分析处理源码的语句啊,这便是词法分析和语法分析,从而把源码变成了抽象语法树(AST).接着只要遍历语法树就得到了字节码指令流.emmm,以目前的垃圾我不可能实现的.那,先从简单的开始,这篇重点就是&lt;strong&gt;从源码验证一下Javac的编译结果&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java垃圾收集器与内存分配策略</title>
      <link>https://leer.moe/2017/09/24/gc/</link>
      <pubDate>Sun, 24 Sep 2017 20:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2017/09/24/gc/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近在看《深入理解Java虚拟机:JVM高级特性与最佳实践》这本书,觉得有必要记录一下.
如无说明,则图片是我用&lt;a href=&#34;#&#34;&gt;Google Drawings&lt;/a&gt;制作的,  under &lt;code&gt;CC BY-NC-SA 3.0 CN&lt;/code&gt; License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;java运行时内存&#34;&gt;Java运行时内存&lt;/h1&gt;
&lt;p&gt;先上图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://leer.moe/images/java_runtime_mem.png&#34; alt=&#34;java_runtime_memory&#34;&gt;&lt;/p&gt;
&lt;p&gt;虽然Java中没有直接(明显)的指针操作,但是在内部的实现里用的还是指针的.在访问对象的过程中,有两种方式可以实现:&lt;strong&gt;句柄访问&lt;/strong&gt;,&lt;strong&gt;直接指针&lt;/strong&gt;.对象实际上是一个reference类型的数据,其中存储的是他自己的地址,通过句柄访问则是句柄的地址.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（五）网页授权获取用户基本信息</title>
      <link>https://leer.moe/2017/05/14/wechat5_web_auth_to_obtain_user_info/</link>
      <pubDate>Sun, 14 May 2017 21:11:28 +0000</pubDate>
      
      <guid>https://leer.moe/2017/05/14/wechat5_web_auth_to_obtain_user_info/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;由于后期需要在微信里跳转网页将用户的openid以及其他信息和学工号绑定，所以需要在通过&lt;a href=&#34;https://mp.weixin.qq.com/wiki/4/9ac2e7b1f1d22e9e57260f6553822520.html#.E7.AC.AC.E5.9B.9B.E6.AD.A5.EF.BC.9A.E6.8B.89.E5.8F.96.E7.94.A8.E6.88.B7.E4.BF.A1.E6.81.AF.28.E9.9C.80scope.E4.B8.BA_snsapi_userinfo.29&#34;&gt;网页授权来获取用户的基本信息&lt;/a&gt;．还有&lt;a href=&#34;https://mp.weixin.qq.com/wiki/1/8a5ce6257f1d3b2afb20f83e72b72ce9.html&#34;&gt;另一种&lt;/a&gt;获取用户信息的接口是直接获取的，就无法和业务进行对接了.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（四）菜单的创建和模板消息的发送</title>
      <link>https://leer.moe/2017/05/11/wechat4_creat_menu_and_send_template_msg/</link>
      <pubDate>Thu, 11 May 2017 22:42:37 +0000</pubDate>
      
      <guid>https://leer.moe/2017/05/11/wechat4_creat_menu_and_send_template_msg/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前面已经成功的获取了access_token，应该已经猜到，菜单的创建和模板消息的发送这两个接口，都要用到access_token．&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（三）Access Token的获取</title>
      <link>https://leer.moe/2017/05/10/wechat3_access_token/</link>
      <pubDate>Wed, 10 May 2017 22:46:24 +0000</pubDate>
      
      <guid>https://leer.moe/2017/05/10/wechat3_access_token/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;access_token是微信公众号开发中比较重要的数据，因为公众号的许多接口都要使用access_token来验证.具体请参考文档(RTFM).&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（二）公众号对接和消息的接收发送</title>
      <link>https://leer.moe/2017/05/04/wecaht2_docking_receipt_and_send/</link>
      <pubDate>Thu, 04 May 2017 12:16:48 +0000</pubDate>
      
      <guid>https://leer.moe/2017/05/04/wecaht2_docking_receipt_and_send/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;上次已经搭建好了开发环境,接着可以和微信公众号进行对接．&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（一）开发环境的搭建</title>
      <link>https://leer.moe/2017/04/20/wechat1_development_of_the_environment/</link>
      <pubDate>Thu, 20 Apr 2017 20:25:34 +0000</pubDate>
      
      <guid>https://leer.moe/2017/04/20/wechat1_development_of_the_environment/</guid>
      <description>&lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;最近参加一个服务外包的比赛，然后就开始了征途，试过py,之后我还是决定用熟悉一点的java.以下内容，我都是在ubuntu 16.04LTS上进行，不保证其他系统适用．(ps:我是在完成了全部功能之后写的这一系列文章，也不能算是教程了，只能算是自己对开发过程的记录)&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>