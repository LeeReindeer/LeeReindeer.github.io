<!doctype html>
<html lang="zh-cn">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>分布式系统设计模式-分布式共识核心 | LeeReindeer&#39;s blog</title>
    <meta property="og:title" content="分布式系统设计模式-分布式共识核心 - LeeReindeer&#39;s blog">
    <meta property="og:type" content="article">
    
    <meta property="article:published_time" content='2021-05-26T18:36:15&#43;08:00'>
    
    
    <meta property="article:modified_time" content='2021-05-26T18:36:15&#43;08:00'>
    
    <meta name="Keywords" content="[设计模式 分布式系统]">
    <meta name="description"
        content="
维护一组提供较强一致性的小型集群（共识核心 Consistent Core），以允许大型数据集群协调服务器活动，而无需自行实现基于quorum的算法。
">
    
    <meta name="author" content="LeeR">
    <meta property="og:url" content="https://leer.moe/2021/05/26/pattern-of-distributed-system-1-consistent-core/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    
    <link href="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" rel="stylesheet">
    

    
    
</head>

<body>
  <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://leer.moe/">
                        LeeReindeer&#39;s blog
                    </a>
                
                <p class="description">Dive in</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://leer.moe/">首页</a>
                    
                    <a  href="https://leer.moe/archives/" title="归档">归档</a>
                    
                    <a  href="https://leer.moe/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

  <div id="body">
    
    <div class="container">
      <div class="col-group">

        <div class="col-8" id="main">
          
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 260px;
        margin-top: 1%;
        right: 8.5%;
         
        margin-right: 1%;
        padding: 5px 10px;
        font-size: 12px;
         
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
         
         
         
        word-wrap: break-word;
        line-height: 1.5;
         
         
         
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 18px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
        color: #ba3925;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">分布式系统设计模式-分布式共识核心</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ol>
    <li><a href="#问题">问题</a></li>
    <li><a href="#方案">方案</a></li>
    <li><a href="#元数据存储">元数据存储</a>
      <ol>
        <li><a href="#支持分层存储">支持分层存储</a></li>
      </ol>
    </li>
    <li><a href="#处理客户端交互">处理客户端交互</a>
      <ol>
        <li><a href="#寻找-leader">寻找 Leader</a></li>
        <li><a href="#处理重复请求">处理重复请求</a></li>
      </ol>
    </li>
    <li><a href="#例子">例子</a></li>
  </ol>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            
            
            
            

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">分布式系统设计模式-分布式共识核心</h1>
        </header>
        <date class="post-meta meta-date">
            2021年5月26日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='https://leer.moe/categories/%E7%BF%BB%E8%AF%91%E9%9B%86'>翻译集</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span>|</span>
            <span class="meta-category">2188 words</span>
        </div>
        
        
        
        <div class="post-content">
            <blockquote>
<p>维护一组提供较强一致性的小型集群（共识核心 Consistent Core），以允许大型数据集群协调服务器活动，而无需自行实现基于<em>quorum</em>的算法。</p>
</blockquote>
<blockquote>
<p><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/consistent-core.html">原文</a></p>
</blockquote>
<h2 id="问题">问题</h2>
<p>当一个集群需要处理大量数据时，它需要更多的服务器。对于集群服务器，有一些共同的要求：例如选择特定的服务器作为特定任务的主服务器（master）；管理集群成员信息；管理数据分片到服务器的映射等。这些要求都需要强一致性的保证，即线性度（linearizability）。并且这种实现也必须具有容错性。一种常见的方法是使用基于<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/quorum.html">Quorum</a>的容错共识算法，但基于 Quorum 的系统，其吞吐量会随着集群的增大而降低。</p>
<h2 id="方案">方案</h2>
<p>实现一个较小的，3 到 5 个节点的集群来提供线性度保证和容错能力。单独的数据集群可使用小型共识集群来管理元数据，并使用诸如<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/time-bound-lease.html">Lease</a>之类的原语来做出集群范围的决策。这样数据集群可以扩容至拥有大量服务器，但是仍能使用较小的元数据集群执行某些需要强一致性保证的操作。</p>
<p>
<a data-fancybox="gallery" href="/images/ConsistentCore.png">
  <img class="mx-auto" alt="Consistent Core" src="/images/ConsistentCore.png" />
</a>
</p>
<p>共识核心的典型接口如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000;font-weight:bold">public</span> <span style="color:#000;font-weight:bold">interface</span> <span style="color:#458;font-weight:bold">ConsistentCore</span> <span style="color:#000;font-weight:bold">{</span>
    CompletableFuture <span style="color:#900;font-weight:bold">put</span><span style="color:#000;font-weight:bold">(</span>String key<span style="color:#000;font-weight:bold">,</span> String value<span style="color:#000;font-weight:bold">);</span>

    List<span style="color:#000;font-weight:bold">&lt;</span>String<span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#900;font-weight:bold">get</span><span style="color:#000;font-weight:bold">(</span>String keyPrefix<span style="color:#000;font-weight:bold">);</span>

    CompletableFuture <span style="color:#900;font-weight:bold">registerLease</span><span style="color:#000;font-weight:bold">(</span>String name<span style="color:#000;font-weight:bold">,</span> <span style="color:#458;font-weight:bold">long</span> ttl<span style="color:#000;font-weight:bold">);</span>

    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">refreshLease</span><span style="color:#000;font-weight:bold">(</span>String name<span style="color:#000;font-weight:bold">);</span>

    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">watch</span><span style="color:#000;font-weight:bold">(</span>String name<span style="color:#000;font-weight:bold">,</span> Consumer<span style="color:#000;font-weight:bold">&lt;</span>WatchEvent<span style="color:#000;font-weight:bold">&gt;</span> watchCallback<span style="color:#000;font-weight:bold">);</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div><p>共识核心至少需要提供一种简单的键值存储机制，它用于存储元数据。</p>
<h2 id="元数据存储">元数据存储</h2>
<p>存储机制时由 Raft 之类的共识算法来实现的。Raft 算法是“复制预写日志”（Replicated Write Ahead Log）的实现，在其中<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/leader-follower.html">Leader and Followers</a>机制用于实现复制，<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/high-watermark.html">High-Water Mark</a>机制用于标记基于 Quorum 的成功复制的副本。</p>
<h3 id="支持分层存储">支持分层存储</h3>
<p>共识核心通常用来存储像这样的数据：集群成员或跨服务器的任务调度。一种常见的方式是使用前缀来限定元数据的类型。例如，对于集群成员，键将全部存储为<code>/servers/1</code>，<code>/servers/2</code>等。对于分配给服务器的任务，键可以是<code>/tasks/task1</code>，<code>/tasks/task2</code>。通常使用所有键带有的特定前缀来读取此数据。比如要获取集群所有服务器的信息，将读取所有前缀带<code>/servers</code>的键。</p>
<p>下面是一个使用用例：</p>
<p>服务器可以通过创建带有<code>/servers</code>的键向共识核心注册自己。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">client1<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">setValue</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;/servers/1&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#d14">&#34;{address:192.168.199.10, port:8000}&#34;</span><span style="color:#000;font-weight:bold">);</span>

client2<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">setValue</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;/servers/2&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#d14">&#34;{address:192.168.199.11, port:8000}&#34;</span><span style="color:#000;font-weight:bold">);</span>

client3<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">setValue</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;/servers/3&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#d14">&#34;{address:192.168.199.12, port:8000}&#34;</span><span style="color:#000;font-weight:bold">);</span>
</code></pre></div><p>客户端可以通过读取带有<code>/servers/</code>前缀的键来获取所有该集群中的服务器：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">assertEquals<span style="color:#000;font-weight:bold">(</span>client1<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">getValue</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;/servers&#34;</span><span style="color:#000;font-weight:bold">),</span>
             Arrays<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">asList</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;{address:192.168.199.12, port:8000}&#34;</span><span style="color:#000;font-weight:bold">,</span>
                           <span style="color:#d14">&#34; {address:192.168.199.11, port:8000}&#34;</span><span style="color:#000;font-weight:bold">,</span>
                           <span style="color:#d14">&#34;{address:192.168.199.10, port:8000}&#34;</span><span style="color:#000;font-weight:bold">));</span>
</code></pre></div><p>由于数据存储的这种分层性质，<a href="https://zookeeper.apache.org">zookeeper</a>, <a href="https://research.google/pubs/pub27897/">chubby</a> 这样的软件提供了类似文件系统的接口，用户可以调用创建目录、文件或者节点，并拥有父节点和子节点的概念。<a href="https://coreos.com/blog/etcd3-a-new-etcd.html">etcd3</a>因拥有平坦键空间而可以读取一个区间内的键。</p>
<h2 id="处理客户端交互">处理客户端交互</h2>
<p>共识核心功能的关键要求之一是客户端如何和核心交互。以下几个方面对于客户端和共识核心的交互来说是至关重要的。</p>
<h3 id="寻找-leader">寻找 Leader</h3>
<p>所有的操作都必须在 Leader 上执行是相当重要的，所以客户端需要先找到 Leader 服务器。下面有两种可行并满足要求的方案：</p>
<ul>
<li>共识核心中的 Follower 服务器知道当前的 Leader 信息，因此如果客户端连接到 Follower 服务器，服务器就能返回 Leader 的地址。然后客户端就能直接连接至在响应中识别出的 Leader 服务器地址。 应该注意的是，当客户端试图连接时，服务器可能正在进行 Leader 选举。这种情况下，服务器不能返回 Leader 的地址，而客户端需要等待并尝试连接其他服务器。</li>
<li>服务器可以实现转发机制，并转发所有客户端的请求到 Leader。这使得客户端可以连接到任何服务器。同样的，如果服务器正在进行 Leader 选举，那么客户端需要重试，直到 Leader 选举成功并选出一个合法的 Leader 为止。</li>
</ul>
<p>像 zookeeper 和 etcd 这样的软件都使用第二种方式实现，因为它们允许一些只读的请求由 Follower 服务器处理。这避免了大量客户端都发起只读请求的情况下，Leader 服务器出现性能瓶颈。这也减轻了客户端根据请求类型连接到 Leader 或 Follower 的复杂度。</p>
<p>寻找 Leader 的一种简单机制是：尝试连接到每个服务器并尝试发送请求，如果服务器不是 Leader，它会返回重定向响应。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000;font-weight:bold">private</span> <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">establishConnectionToLeader</span><span style="color:#000;font-weight:bold">(</span>List<span style="color:#000;font-weight:bold">&lt;</span>InetAddressAndPort<span style="color:#000;font-weight:bold">&gt;</span> servers<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
    <span style="color:#000;font-weight:bold">for</span> <span style="color:#000;font-weight:bold">(</span>InetAddressAndPort server <span style="color:#000;font-weight:bold">:</span> servers<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
        <span style="color:#000;font-weight:bold">try</span> <span style="color:#000;font-weight:bold">{</span>
            SingleSocketChannel socketChannel <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> SingleSocketChannel<span style="color:#000;font-weight:bold">(</span>server<span style="color:#000;font-weight:bold">,</span> 10<span style="color:#000;font-weight:bold">);</span>
            logger<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">info</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;Trying to connect to &#34;</span> <span style="color:#000;font-weight:bold">+</span> server<span style="color:#000;font-weight:bold">);</span>
            RequestOrResponse response <span style="color:#000;font-weight:bold">=</span> sendConnectRequest<span style="color:#000;font-weight:bold">(</span>socketChannel<span style="color:#000;font-weight:bold">);</span>
            <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>isRedirectResponse<span style="color:#000;font-weight:bold">(</span>response<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
                redirectToLeader<span style="color:#000;font-weight:bold">(</span>response<span style="color:#000;font-weight:bold">);</span>
                <span style="color:#000;font-weight:bold">break</span><span style="color:#000;font-weight:bold">;</span>
            <span style="color:#000;font-weight:bold">}</span> <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span>isLookingForLeader<span style="color:#000;font-weight:bold">(</span>response<span style="color:#000;font-weight:bold">))</span> <span style="color:#000;font-weight:bold">{</span>
                logger<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">info</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;Server is looking for leader. Trying next server&#34;</span><span style="color:#000;font-weight:bold">);</span>
                <span style="color:#000;font-weight:bold">continue</span><span style="color:#000;font-weight:bold">;</span>
            <span style="color:#000;font-weight:bold">}</span> <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#998;font-style:italic">//we know the leader
</span><span style="color:#998;font-style:italic"></span>                logger<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">info</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;Found leader. Establishing a new connection.&#34;</span><span style="color:#000;font-weight:bold">);</span>
                newPipelinedConnection<span style="color:#000;font-weight:bold">(</span>server<span style="color:#000;font-weight:bold">);</span>
                <span style="color:#000;font-weight:bold">break</span><span style="color:#000;font-weight:bold">;</span>
            <span style="color:#000;font-weight:bold">}</span>
        <span style="color:#000;font-weight:bold">}</span> <span style="color:#000;font-weight:bold">catch</span> <span style="color:#000;font-weight:bold">(</span>IOException e<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
            logger<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">info</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;Unable to connect to &#34;</span> <span style="color:#000;font-weight:bold">+</span> server<span style="color:#000;font-weight:bold">);</span>
            <span style="color:#998;font-style:italic">//try next server
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">}</span>
    <span style="color:#000;font-weight:bold">}</span>
<span style="color:#000;font-weight:bold">}</span>

<span style="color:#000;font-weight:bold">private</span> <span style="color:#458;font-weight:bold">boolean</span> <span style="color:#900;font-weight:bold">isLookingForLeader</span><span style="color:#000;font-weight:bold">(</span>RequestOrResponse requestOrResponse<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
    <span style="color:#000;font-weight:bold">return</span> requestOrResponse<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">getRequestId</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">==</span> RequestId<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">LookingForLeader</span><span style="color:#000;font-weight:bold">.</span><span style="color:#008080">getId</span><span style="color:#000;font-weight:bold">();</span>
<span style="color:#000;font-weight:bold">}</span>

<span style="color:#000;font-weight:bold">private</span> <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">redirectToLeader</span><span style="color:#000;font-weight:bold">(</span>RequestOrResponse response<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
    RedirectToLeaderResponse redirectResponse <span style="color:#000;font-weight:bold">=</span> deserialize<span style="color:#000;font-weight:bold">(</span>response<span style="color:#000;font-weight:bold">);</span>
    newPipelinedConnection<span style="color:#000;font-weight:bold">(</span>redirectResponse<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">leaderAddress</span><span style="color:#000;font-weight:bold">);</span>

    logger<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">info</span><span style="color:#000;font-weight:bold">(</span><span style="color:#d14">&#34;Connected to the new leader &#34;</span>
            <span style="color:#000;font-weight:bold">+</span> redirectResponse<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">leaderServerId</span>
            <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#34; &#34;</span> <span style="color:#000;font-weight:bold">+</span> redirectResponse<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">leaderAddress</span>
            <span style="color:#000;font-weight:bold">+</span> <span style="color:#d14">&#34;. Checking connection&#34;</span><span style="color:#000;font-weight:bold">);</span>
<span style="color:#000;font-weight:bold">}</span>


<span style="color:#000;font-weight:bold">private</span> <span style="color:#458;font-weight:bold">boolean</span> <span style="color:#900;font-weight:bold">isRedirectResponse</span><span style="color:#000;font-weight:bold">(</span>RequestOrResponse requestOrResponse<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
    <span style="color:#000;font-weight:bold">return</span> requestOrResponse<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">getRequestId</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">==</span> RequestId<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">RedirectToLeader</span><span style="color:#000;font-weight:bold">.</span><span style="color:#008080">getId</span><span style="color:#000;font-weight:bold">();</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div><p>仅仅建立 TCP 连接是不够的，我们需要知道服务器能否处理我们的请求。所以客户端发送一个特殊的连接请求，让服务器确认它能否处理请求，否则就重定向到 Leader 服务器。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000;font-weight:bold">private</span> RequestOrResponse <span style="color:#900;font-weight:bold">sendConnectRequest</span><span style="color:#000;font-weight:bold">(</span>SingleSocketChannel socketChannel<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">throws</span> IOException <span style="color:#000;font-weight:bold">{</span>
    RequestOrResponse request
            <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">new</span> RequestOrResponse<span style="color:#000;font-weight:bold">(</span>RequestId<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">ConnectRequest</span><span style="color:#000;font-weight:bold">.</span><span style="color:#008080">getId</span><span style="color:#000;font-weight:bold">(),</span> <span style="color:#d14">&#34;CONNECT&#34;</span><span style="color:#000;font-weight:bold">,</span> 0<span style="color:#000;font-weight:bold">);</span>
    <span style="color:#000;font-weight:bold">try</span> <span style="color:#000;font-weight:bold">{</span>
        <span style="color:#000;font-weight:bold">return</span> socketChannel<span style="color:#000;font-weight:bold">.</span><span style="color:#008080">blockingSend</span><span style="color:#000;font-weight:bold">(</span>request<span style="color:#000;font-weight:bold">);</span>
    <span style="color:#000;font-weight:bold">}</span> <span style="color:#000;font-weight:bold">catch</span> <span style="color:#000;font-weight:bold">(</span>IOException e<span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
        resetConnectionToLeader<span style="color:#000;font-weight:bold">();</span>
        <span style="color:#000;font-weight:bold">throw</span> e<span style="color:#000;font-weight:bold">;</span>
    <span style="color:#000;font-weight:bold">}</span>
<span style="color:#000;font-weight:bold">}</span>
</code></pre></div><p>如果现有的 Leader 服务器宕机了，相同的技术被用来确定从集群中新选出的 Leader。</p>
<p>一旦连接，客户端就会维持一个单套接字通道（<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/single-socket-channel.html">Single Socket Channel</a>）到 Leader 服务器。</p>
<h3 id="处理重复请求">处理重复请求</h3>
<p>在请求失败的情况下，客户端可能尝试连接至新的 leader，并重新发送请求。但是如果这些请求在失败之前已经被宕机的 leader 处理了，就可能导致重复处理。因此，在服务器上设置一个忽略重复请求的制止时很重要的。<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/idempotent-receiver.html">Idempotent Receiver</a> 模式就被用来实现重复检测。</p>
<p>协调一组服务器之间的任务可以通过使用<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/time-bound-lease.html">Lease</a>来完成。它同样可以用来实现组成员和故障检测机制。</p>
<p><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/state-watch.html">State Watch</a> 用来获取元数据或限时租约的变化通知。</p>
<h2 id="例子">例子</h2>
<p>众所周知，谷歌使用[<a href="https://research.google/pubs/pub27897/">chubby]</a>锁服务进行协调和元数据管理。</p>
<p>[<a href="https://kafka.apache.org/">kafka]</a> 使用 [<a href="https://zookeeper.apache.org/">zookeeper]</a>来管理元数据并做出决定，如集群选主。 Kafka 的<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-500%3A+Replace+ZooKeeper+with+a+Self-Managed+Metadata+Quorum">架构提议变化</a>将用它自己基于 Raft 的控制集群来取代 zookeeper。</p>
<p>[<a href="https://bookkeeper.apache.org/">bookkeeper]</a>使用 zookeeper 来管理集群元数据。</p>
<p>[<a href="https://kubernetes.io/">kubernetes]</a> 使用 [<a href="https://etcd.io/">etcd]</a> 来协调管理机群元数据和成员信息。</p>
<p>所有的大数据存储和处理系统，如 [<a href="https://hadoop.apache.org/docs/r3.0.0/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithNFS.html">hdfs]</a>, [<a href="http://spark.apache.org/docs/latest/spark-standalone.html#standby-masters-with-zookeeper">spark]</a>和 [<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/jobmanager_high_availability.html">flink]</a> 都使用 [<a href="https://zookeeper.apache.org/">zookeeper]</a>来实现高可用和集群协调。</p>
        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/2021/01/31/pattern-of-distribeted-system-0/">分布式系统设计模式-综述</a></li>
        
        <li><a href="/2018/01/02/tree2view_final_report/">Android Tree2View 3-Core Alogrithm</a></li>
        
        <li><a href="/2017/12/25/my_treeview_2_adapder/">Android Tree2View 2-Adapter in Tree2View</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://leer.moe/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F'>分布式系统</a></li>
                
                <li><a href='https://leer.moe/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F'>设计模式</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "LeeReindeer/LeeReindeer.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

        </div>
        
        
        
        
      </div>
    </div>
  </div>
  <footer id="footer">
    <div class="container">
        &copy; 2021 <a href="https://leer.moe/">LeeReindeer&#39;s blog</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>
        <a href="https://github.com/LeeReindeer/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
    <div class="container" id="showDays"></div>
</footer>
<script type="text/javascript" src='/js/sitedate.js' async=""></script>





<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>






</body>

</html>