<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on LeeReindeer&#39;s blog</title>
    <link>https://leer.moe/tags/Java/</link>
    <description>Recent content in Java on LeeReindeer&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 25 Apr 2019 19:31:21 +0000</lastBuildDate><atom:link href="https://leer.moe/tags/Java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AbstractQueuedSynchronizer</title>
      <link>https://leer.moe/2019/04/25/java-concurrent-aqs/</link>
      <pubDate>Thu, 25 Apr 2019 19:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/04/25/java-concurrent-aqs/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;AQS 是用来构建锁和同步工具的基本框架。本文主要基于 AQS 作者 Doug Lea 的论文*&lt;a href=&#34;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&#34;&gt;The java.util.concurrent Synchronizer Framework&lt;/a&gt;* 和 JDK 1.8 的文档。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leer.moe/2019/01/06/java-concurrent-toc/&#34;&gt;Java并发-目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>数据结构-二叉树</title>
      <link>https://leer.moe/2019/03/18/binary-tree/</link>
      <pubDate>Mon, 18 Mar 2019 15:49:47 +0000</pubDate>
      
      <guid>https://leer.moe/2019/03/18/binary-tree/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二叉树的&lt;strong&gt;第 i 层最多有$2^{i-1}$个节点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;深度为 h 的二叉树最多有$2^h - 1$个节点&lt;/strong&gt;。定义根节点深度为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n_0$(度为 0 的节点，叶子节点)，$n_1$（度为 1 的节点），$n_2$（度为 2 的节点），有 $n_0 = n_2 + 1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;n0+n1+n2-1 = 0*n0+1*n1+2*n2

n0 = n2+1
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>单线程和多线程下的ConcurrentModificationException</title>
      <link>https://leer.moe/2019/03/11/ConcurrentModificationException/</link>
      <pubDate>Mon, 11 Mar 2019 22:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/03/11/ConcurrentModificationException/</guid>
      <description>这个寒假看的《Java并发编程实战》终于派上了用场，今天搬砖过程中遇到了ConcurrentModificationException，结果</description>
    </item>
    
    <item>
      <title>Java并发-Synchronized和Reentrantlock</title>
      <link>https://leer.moe/2019/01/07/java-concurrent-synchronized-reentrantlock/</link>
      <pubDate>Mon, 07 Jan 2019 10:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/01/07/java-concurrent-synchronized-reentrantlock/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Java中对线程的同步和互斥有两种方式：使用&lt;code&gt;synchronized&lt;/code&gt;关键字和使用&lt;code&gt;ReentranLock&lt;/code&gt; 。也有其他的实现比如信号量，在操作系统里也有学到。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leer.moe/2019/01/06/java-concurrent-toc/&#34;&gt;Java并发-目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Java并发-目录</title>
      <link>https://leer.moe/2019/01/06/java-concurrent-toc/</link>
      <pubDate>Sun, 06 Jan 2019 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2019/01/06/java-concurrent-toc/</guid>
      <description>Java 并发编程笔记目录 synchronized 和 ReentrantLock AQS volatile 关键字 单线程和多线程下的ConcurrentModificationExceptio &amp;hellip;</description>
    </item>
    
    <item>
      <title>Java基础-Pass by value</title>
      <link>https://leer.moe/2018/12/20/java-fun-pass-by-value/</link>
      <pubDate>Thu, 20 Dec 2018 16:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/20/java-fun-pass-by-value/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Java的方法参数是按值传递的，这篇主要是把Java的传值机制和C语言的指针和二重指针进行比较，并基于汇编代码更深入的理解传值和传引用。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>数据结构-Treap</title>
      <link>https://leer.moe/2018/12/17/data-structrue-treap/</link>
      <pubDate>Mon, 17 Dec 2018 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/17/data-structrue-treap/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;今天的算法课上，老师讲了一个比较有意思的数据结构：&lt;code&gt;Treap&lt;/code&gt;。它的名字就比较有意思，为什么叫&lt;code&gt;Treap&lt;/code&gt;呢？是Tree + Heap两个单词的结合，所以这个数据结构也就是二叉树和二叉堆的结合了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Treap也是平衡二叉搜索树的一种。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Balanced Binary Search Tree 也可以简称为 Balanced Search Tree，为了方便区分我下面会简称为&lt;code&gt;BBST&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Java基础-ArrayList和LinkedList</title>
      <link>https://leer.moe/2018/12/17/java-fun-arraylist-linkedlist/</link>
      <pubDate>Mon, 17 Dec 2018 15:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/17/java-fun-arraylist-linkedlist/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;相对与&lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;LinkedList&lt;/code&gt;都算比较简单的数据结构，通过这篇文章分别的了解一下它们。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Java基础-HashMap源码简析</title>
      <link>https://leer.moe/2018/12/16/java-fun-hashmap/</link>
      <pubDate>Sun, 16 Dec 2018 12:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/16/java-fun-hashmap/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;基于&lt;code&gt;HashMap&lt;/code&gt;JDK1.8中的源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考前辈们的成果，简单的分析&lt;code&gt;HashMap&lt;/code&gt;的源码，了解一下&lt;code&gt;HashMap&lt;/code&gt;的存储结构，主要方法工作原理和线程安全这几个方面。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础-Object的11个方法</title>
      <link>https://leer.moe/2018/12/14/java-fun-object-method/</link>
      <pubDate>Fri, 14 Dec 2018 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/14/java-fun-object-method/</guid>
      <description>&lt;p&gt;一切从对象开始。在Java中Object类是是所有类的父类，也是根类。它一共有11个方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java基础-目录</title>
      <link>https://leer.moe/2018/12/12/java-fun-toc/</link>
      <pubDate>Wed, 12 Dec 2018 18:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/12/12/java-fun-toc/</guid>
      <description>接下来应该会写一系列Java基础的笔记吧，之前虽觉得自己已经熟悉Java，但都没有系统的做笔记和整理，而且Java也是自学的，很多知识都没有</description>
    </item>
    
    <item>
      <title>【Spring 揭秘（一）】Spring Bean DI and Instantiating</title>
      <link>https://leer.moe/2018/11/10/spring_bean/</link>
      <pubDate>Sat, 10 Nov 2018 14:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/11/10/spring_bean/</guid>
      <description>&lt;h2 id=&#34;cheatsheet&#34;&gt;cheatsheet&lt;/h2&gt;
&lt;p&gt;如果你赶时间，可以只看这一节的内容。&lt;/p&gt;
&lt;h3 id=&#34;bean-的实例化方式&#34;&gt;bean 的实例化方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XML 配置时
&lt;ul&gt;
&lt;li&gt;工厂方法&lt;/li&gt;
&lt;li&gt;静态工厂&lt;/li&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注解方式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于注解方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@Component：可以用于注册所有bean&lt;/li&gt;
&lt;li&gt;@Repository：主要用于注册dao层的bean&lt;/li&gt;
&lt;li&gt;@Controller：主要用于注册控制层的bean&lt;/li&gt;
&lt;li&gt;@Service：主要用于注册服务层的bean&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;spring-bean-的注入方式&#34;&gt;Spring bean 的注入方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XML配置
&lt;ul&gt;
&lt;li&gt;setter 方法注入&lt;/li&gt;
&lt;li&gt;构造函数注入&lt;/li&gt;
&lt;li&gt;工厂方法/静态工厂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注解方式注入（&lt;code&gt;@AutoWired&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Map DateTime to Java Date in MyBatis</title>
      <link>https://leer.moe/2018/11/07/mybatis_datetime/</link>
      <pubDate>Wed, 07 Nov 2018 10:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2018/11/07/mybatis_datetime/</guid>
      <description>问题 最近在用 Spring Boot 重写 LightBlog，查询到的博客的 Date 属性的日期正常，但是时间始终为 00:00:00。 resultMap 映射如下： 1 2 3 4 5 6 7 8 9 10 &amp;lt;resultMap id=&amp;#34;blogMap&amp;#34;</description>
    </item>
    
    <item>
      <title>Read source code of Javac-1</title>
      <link>https://leer.moe/2017/10/21/read_javac_1/</link>
      <pubDate>Sat, 21 Oct 2017 18:46:18 +0000</pubDate>
      
      <guid>https://leer.moe/2017/10/21/read_javac_1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近发生太多不愉快的事, 还是看看源码压压惊(.这篇大概有很多错误.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-说在前面&#34;&gt;1. 说在前面&lt;/h2&gt;
&lt;p&gt;Javac 大家(只是习惯用大家)应该用的很熟悉了.想我第一次接触 java 就是从 Javac 编译第一个程序的.到了今天,我时不时也会想这到底是怎么实现的?这个想法一直挥之不去.咦,跑题了(.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;代码编译的结果是从本地机器码转变成字节码,是存储格式发展的一小步,却是编程语言发展的一大步.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话反复出现在《深入理解Java虚拟机》里.我倒是没有体会到什么发展,也可以理解为这是为了跨平台而做出的牺牲,虚拟机也为此出现.当然也有直接把 Java 源代码编译成机器码的编译器( AOT 编译器).先不管这个,从 Java 源代码到字节码到底经历了什么呢?肯定要分析处理源码的语句啊,这便是词法分析和语法分析,从而把源码变成了抽象语法树(AST).接着只要遍历语法树就得到了字节码指令流.emmm,以目前的垃圾我不可能实现的.那,先从简单的开始,这篇重点就是&lt;strong&gt;从源码验证一下Javac的编译结果&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java垃圾收集器与内存分配策略</title>
      <link>https://leer.moe/2017/09/24/gc/</link>
      <pubDate>Sun, 24 Sep 2017 20:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2017/09/24/gc/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近在看《深入理解Java虚拟机:JVM高级特性与最佳实践》这本书,觉得有必要记录一下.
如无说明,则图片是我用&lt;a href=&#34;#&#34;&gt;Google Drawings&lt;/a&gt;制作的,  under &lt;code&gt;CC BY-NC-SA 3.0 CN&lt;/code&gt; License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;java运行时内存&#34;&gt;Java运行时内存&lt;/h1&gt;
&lt;p&gt;先上图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://leer.moe/images/java_runtime_mem.png&#34; alt=&#34;java_runtime_memory&#34;&gt;&lt;/p&gt;
&lt;p&gt;虽然Java中没有直接(明显)的指针操作,但是在内部的实现里用的还是指针的.在访问对象的过程中,有两种方式可以实现:&lt;strong&gt;句柄访问&lt;/strong&gt;,&lt;strong&gt;直接指针&lt;/strong&gt;.对象实际上是一个reference类型的数据,其中存储的是他自己的地址,通过句柄访问则是句柄的地址.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Google Java 代码规范</title>
      <link>https://leer.moe/2017/09/18/google-java-style-guide/</link>
      <pubDate>Mon, 18 Sep 2017 20:31:21 +0000</pubDate>
      
      <guid>https://leer.moe/2017/09/18/google-java-style-guide/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Translation of &lt;a href=&#34;https://google.github.io/styleguide/javaguide.html&#34;&gt;Google Java Style Guide&lt;/a&gt;,by &lt;a href=&#34;http://leezoom.xyz&#34;&gt;Lee&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转载请注明出处.This Translation is under &lt;code&gt;CC BY-NC-SA 3.0 CN&lt;/code&gt; License.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://drive.google.com/file/d/0B3PS61RbeCWjRHBqZFk0WjktRWs/view?usp=sharing&#34;&gt;下载pdf&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（五）网页授权获取用户基本信息</title>
      <link>https://leer.moe/2017/05/14/wechat5_web_auth_to_obtain_user_info/</link>
      <pubDate>Sun, 14 May 2017 21:11:28 +0000</pubDate>
      
      <guid>https://leer.moe/2017/05/14/wechat5_web_auth_to_obtain_user_info/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;由于后期需要在微信里跳转网页将用户的openid以及其他信息和学工号绑定，所以需要在通过&lt;a href=&#34;https://mp.weixin.qq.com/wiki/4/9ac2e7b1f1d22e9e57260f6553822520.html#.E7.AC.AC.E5.9B.9B.E6.AD.A5.EF.BC.9A.E6.8B.89.E5.8F.96.E7.94.A8.E6.88.B7.E4.BF.A1.E6.81.AF.28.E9.9C.80scope.E4.B8.BA_snsapi_userinfo.29&#34;&gt;网页授权来获取用户的基本信息&lt;/a&gt;．还有&lt;a href=&#34;https://mp.weixin.qq.com/wiki/1/8a5ce6257f1d3b2afb20f83e72b72ce9.html&#34;&gt;另一种&lt;/a&gt;获取用户信息的接口是直接获取的，就无法和业务进行对接了.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（四）菜单的创建和模板消息的发送</title>
      <link>https://leer.moe/2017/05/11/wechat4_creat_menu_and_send_template_msg/</link>
      <pubDate>Thu, 11 May 2017 22:42:37 +0000</pubDate>
      
      <guid>https://leer.moe/2017/05/11/wechat4_creat_menu_and_send_template_msg/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前面已经成功的获取了access_token，应该已经猜到，菜单的创建和模板消息的发送这两个接口，都要用到access_token．&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（三）Access Token的获取</title>
      <link>https://leer.moe/2017/05/10/wechat3_Access_Token/</link>
      <pubDate>Wed, 10 May 2017 22:46:24 +0000</pubDate>
      
      <guid>https://leer.moe/2017/05/10/wechat3_Access_Token/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;access_token是微信公众号开发中比较重要的数据，因为公众号的许多接口都要使用access_token来验证.具体请参考文档(RTFM).&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（二）公众号对接和消息的接收发送</title>
      <link>https://leer.moe/2017/05/04/wecaht2_docking_receipt_and_send/</link>
      <pubDate>Thu, 04 May 2017 12:16:48 +0000</pubDate>
      
      <guid>https://leer.moe/2017/05/04/wecaht2_docking_receipt_and_send/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;上次已经搭建好了开发环境,接着可以和微信公众号进行对接．&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>一个微信公众号的诞生（一）开发环境的搭建</title>
      <link>https://leer.moe/2017/04/20/wechat1_development_of_the_environment/</link>
      <pubDate>Thu, 20 Apr 2017 20:25:34 +0000</pubDate>
      
      <guid>https://leer.moe/2017/04/20/wechat1_development_of_the_environment/</guid>
      <description>&lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;最近参加一个服务外包的比赛，然后就开始了征途，试过py,之后我还是决定用熟悉一点的java.以下内容，我都是在ubuntu 16.04LTS上进行，不保证其他系统适用．(ps:我是在完成了全部功能之后写的这一系列文章，也不能算是教程了，只能算是自己对开发过程的记录)&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
