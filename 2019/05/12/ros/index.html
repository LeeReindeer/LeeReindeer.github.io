<!doctype html>
<html lang="zh-cn">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>RTOS设计与实现 | LeeReindeer&#39;s blog</title>
    <meta property="og:title" content="RTOS设计与实现 - LeeReindeer&#39;s blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2019-05-12T18:31:21&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2019-05-12T18:31:21&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="RTOS设计与实现">
        
    <meta name="author" content="">
    <meta property="og:url" content="https://leer.moe/2019/05/12/ros/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://leer.moe/">
                        LeeReindeer&#39;s blog
                    </a>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://leer.moe/">首页</a>
                    
                    <a  href="https://leer.moe/archives/" title="归档">归档</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#我想要怎么的rtos">我想要怎么的RTOS</a></li>
    <li><a href="#需求分析">需求分析</a></li>
    <li><a href="#技术方案">技术方案</a></li>
    <li><a href="#开发流程">开发流程</a></li>
    <li><a href="#数据结构">数据结构</a>
      <ul>
        <li><a href="#就绪队列">就绪队列</a></li>
        <li><a href="#阻塞队列">阻塞队列</a></li>
      </ul>
    </li>
    <li><a href="#初始化">初始化</a>
      <ul>
        <li><a href="#初始化系统">初始化系统</a></li>
        <li><a href="#上下文是什么">上下文是什么？</a></li>
        <li><a href="#初始化上下文">初始化上下文</a></li>
      </ul>
    </li>
    <li><a href="#任务调度算法">任务调度算法</a>
      <ul>
        <li><a href="#isr">ISR</a></li>
        <li><a href="#队列操作">队列操作</a></li>
        <li><a href="#ros_schedule">ros_schedule</a></li>
        <li><a href="#上下文切换">上下文切换</a></li>
      </ul>
    </li>
    <li><a href="#ros_delay">ros_delay</a></li>
    <li><a href="#构建">构建</a></li>
    <li><a href="#示例">示例</a></li>
    <li><a href="#和freertos比较">和FreeRTOS比较</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考文献">参考文献</a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if (leftPos < 220) {
                postToc.css({ "width": leftPos - 10, "margin-left": (0 - leftPos) })
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">RTOS设计与实现</h1>
        </header>
        <date class="post-meta meta-date">
            2019年5月12日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='https://leer.moe/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4'>实验室</a></span>
            
        </div>
        
        
        
        <div class="post-content">
            <blockquote>
<p>介绍基于 AVR 的 RTOS 的设计和实现，名为 ROS。</p>
<p><a href="https://github.com/LeeReindeer/ROS">GitHub 地址</a></p>
</blockquote>
<h2 id="我想要怎么的rtos">我想要怎么的RTOS</h2>
<p>ROS作为一个RTOS（Real-Time Operating System）的实现，它的核心是 scheduler（调度器），负责任务的调度。而其他的系统工具比如： Semaphore、 Queue 都可以在此基础上实现。</p>
<p>对于嵌入式系统来说，如果需要一个操作系统，那么它应该是轻量级的。因为嵌入式系统的内存通常有限制。对于我来说，去实现一个复杂的，重量级的操作系统，也不太可能。</p>
<p>所以我的RTOS应该是这样（实际上也确实是这样）：</p>
<ol>
<li>轻量：实现  preemtive priority scheduler、semaphore，即任务调度和任务通信</li>
<li>简单：基于优先队列的 scheduler。使用排序链表实现，实现简单。插入O(N)，取出最高优先级元素O(1)。</li>
</ol>
<h2 id="需求分析">需求分析</h2>
<p>嵌入式系统上真的需要操作系统吗？或者说使用操作系统有什么优点？</p>
<p>回答这个问题之前，我们先回想一下日常使用的手机，是不是都搭载了一个系统（比如 Android 或者 iOS），有了操作系统我们可以一边听歌一边聊天，也就是 Multitasking。</p>
<p>如果需要实现的业务比较简单，那么不使用操作系统也可以轻松的完成；对于复杂的逻辑和业务，也有几个解决方法：使用有限状态机或者使用操作系统。</p>
<p>相比于有限状态机的方法，或者采用普通的方式编程，使用操作系统有下面这些优势：</p>
<ul>
<li>
<p>大幅简化业务逻辑和代码。RTOS 提供多任务（和现代操作系统的多线程类似）运行的功能。而使用状态机则会有很多 if、switch 的状态判断。操作系统很好的隐藏了底层细节，提供给用户简单的接口以供使用。</p>
</li>
<li>
<p>可以快速，一致的响应中断。快速的响应中断和处理中断是 RTOS 的实现要求，所谓的“实时”就是对中断的快速响应。</p>
</li>
<li>
<p>不需要 busy-wating（忙等）。RTOS可以提供 Semaphore、Queue 之类的任务通信工具。比如使用 Semaphore 之后，就不需要忙等一个 Flag，而当条件不满足时，当前任务会从就绪队列中移除。当条件满足时，唤醒该任务。</p>
</li>
</ul>
<h2 id="技术方案">技术方案</h2>
<p>ROS 主要用 C 语言开发，只有scheduler 的核心部分用 Inline Assembly 实现。开发过程中的工具如下：</p>
<ul>
<li>
<p>AVR-GCC：AVR平台的GCC编译器</p>
</li>
<li>
<p>ARV-GDB：AVR平台的 Debugger</p>
</li>
<li>
<p>SimAVR：AVR 模拟器，可以将程序在模拟器上测试</p>
</li>
<li>
<p>Make：Unix下的构建工具，用于构建整个系统</p>
</li>
</ul>
<h2 id="开发流程">开发流程</h2>
<ol>
<li>阅读 FreeRTOS 的实现和 Atomthreads 的代码</li>
<li>编写代码</li>
<li>编写测试</li>
<li>使用 Makefile 构建上传</li>
<li>在 simavr 上测试</li>
<li>真机测试</li>
<li>作为 Arduino Library，在 Arduino IDE 中使用</li>
</ol>
<p>思路：利用 timer 产生周期性中断，在系统中加入一个默认任务。在ISR中调用 scheduler，选择优先级最高的任务（对于相同优先级的任务，使用 round-robin），之后进行上下文切换。同时任务可以主动让出 CPU，让其他低优先级的任务切入。</p>
<p>当一个任务主动让出 CPU，即调用系统函数 ros_delay 时，当前任务不再入队（就绪队列），而是保存在一个阻塞队列中（阻塞任务）。在ISR中检查是否有任务的delay到期，则重新将其加入就绪队列（唤醒任务）。</p>
<p>同时我为每个函数都写了详细的英文注解，在贴代码的同时我会连着注解一起贴上来。</p>
<p>下面简要说明ROS提供的内核API：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 初始化系统
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ros_init</span>();
<span style="color:#75715e">// 获取当前在运行的任务
</span><span style="color:#75715e"></span>ROS_TCB <span style="color:#f92672">*</span><span style="color:#a6e22e">ros_current_tcb</span>();
<span style="color:#75715e">// 创建任务
</span><span style="color:#75715e"></span>status_t <span style="color:#a6e22e">ros_create_task</span>(ROS_TCB <span style="color:#f92672">*</span>tcb, task_func task, uint8_t priority,stack_t <span style="color:#f92672">*</span>stack, <span style="color:#66d9ef">int</span> stack_size);
<span style="color:#75715e">// 任务调度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_schedule</span>();

<span style="color:#75715e">// 阻塞任务，以 System tick 为单位
</span><span style="color:#75715e"></span>status_t <span style="color:#a6e22e">ros_delay</span>(uint32_t ticks);

<span style="color:#75715e">// 下面四个函数,是移植 ROS 时需要实现的
</span><span style="color:#75715e">// 初始化 Timer
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_init_timer</span>();
<span style="color:#75715e">// 默认任务
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_idle_task</span>();
<span style="color:#75715e">// 初始化任务栈
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_task_context_init</span>(ROS_TCB <span style="color:#f92672">*</span>tcb_ptr, task_func task_f,<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>stack_top);
<span style="color:#75715e">// 上下文切换
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_switch_context</span>(ROS_TCB <span style="color:#f92672">*</span>old_tcb, ROS_TCB <span style="color:#f92672">*</span>new_tcb);
</code></pre></div><h2 id="数据结构">数据结构</h2>
<h3 id="就绪队列">就绪队列</h3>
<p>根据上面的思路，我们需要两个队列：就绪队列和阻塞队列。就绪队列保存所有就绪的任务，并且按照优先级降序；阻塞队列保存阻塞的任务。</p>
<p>首先定义任务的数据结构：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> {
TASK_READY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
TASK_BLOCKED,
TASK_TERMINATED
} Task_Status;

<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>task_func)();
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ros_tcb {
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>sp;
Task_Status status;
uint8_t priority; <span style="color:#75715e">// 0~255
</span><span style="color:#75715e"></span>task_func task_entry;
<span style="color:#66d9ef">struct</span> ros_tcb <span style="color:#f92672">*</span>next_tcb;
} ROS_TCB;
</code></pre></div><p>代码中定义了三种任务状态：READY、BLOCKED 和 TERMINATED。如图 2所示，其实还有一种 RUNNING 状态，这种状态存在，但是不需要显式的表明，因为我们会用 current_tcb 来存储当前运行的任务，所以我在编码的后期删除了 RUNNING 状态。</p>
<p><img src="/images/task-status.png" alt="图2 task status"></p>
<p>任务的优先级为0～255，规定0为优先级最高，255为优先级最低。所以越小的数字，表示优先级越高。</p>
<p>sp 保存任务的栈指针，我们为每个任务都分配一个单独的栈。我们把 sp 放在结构体的首位也是别有用意的，因为在 3.3.4上下文切换 时，我们需要改变系统的栈指针，将系统栈指针指向一个 ROS_TCB 结构体，也就指向了该任务的栈指针。</p>
<p>next_tcb 指针保存下一个任务，和FreeRTOS和AtomThreads等RTOS不同，ROS的就绪列表是一个单链表。使用双向链表的优势在这里不明显，并且会增加一个指针的内存使用。使用单链表使得链表的操作简单，不容易出错。</p>
<p>接下来就是任务的本体，一个任务函数指针，我们的业务逻辑也是卸载这个函数中。下面是一个任务函数的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">task1</span>() {
<span style="color:#66d9ef">for</span>(;;) {
<span style="color:#75715e">// task code here
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">// should never return, once return the task will be deleted from the ready list
</span><span style="color:#75715e"></span>}
</code></pre></div><p>一个典型的任务是把逻辑写在无限循环中。当然你也可以从这个任务中 return，这样的话它就是一个 run-to-compeletion 任务，任务状态变为 TERMINATED，很快会被从就绪列表中删除，并永远不再运行。</p>
<h3 id="阻塞队列">阻塞队列</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ros_timer {
ROS_TCB <span style="color:#f92672">*</span>blocked_tcb;
uint32_t ticks;
<span style="color:#66d9ef">struct</span> ros_timer <span style="color:#f92672">*</span>next_timer;
} ROS_TIMER
</code></pre></div><p>和就绪队列类似，阻塞队列也是一个单链表。但是阻塞队列不是有序的。Ticks 保存任务需要延迟的 System tick 数，当 ticks 数递减为 0 时，唤醒该任务。</p>
<h2 id="初始化">初始化</h2>
<h3 id="初始化系统">初始化系统</h3>
<p>初始化系统分为两步骤，初始化过程中关闭中断：</p>
<ol>
<li>
<p>配置 timer</p>
</li>
<li>
<p>创建一个 idle（默认） 任务到 ready list，保证系统总有任务在运行</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * @brief  Start the os:
</span><span style="color:#75715e"> * 1. init the system timer, start ticking
</span><span style="color:#75715e"> * 2. add a idle task into the list
</span><span style="color:#75715e"> * @retval ture if os started
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ros_init</span>() {
  CRITICAL_STORE;
  CRITICAL_START();
  ros_init_timer();
  status_t ok <span style="color:#f92672">=</span>
      ros_create_task(<span style="color:#f92672">&amp;</span>idle_tcb, ros_idle_task, MIN_TASK_PRIORITY, idle_task_stack, ROS_IDLE_STACK_SIZE);
  ROS_STARTED <span style="color:#f92672">=</span> ok <span style="color:#f92672">==</span> ROS_OK;
  CRITICAL_END();
  <span style="color:#66d9ef">return</span> ROS_STARTED;
}
</code></pre></div><h4 id="配置timer">配置Timer</h4>
<p>Timer（定时器）的配置根据平台的不同而不同，对与 Arduino Uno，它拥有三个 timer，我这里选择 Timer1 作为ROS产生 system tick 的 timer，因为使用了 Timer1，而 Timer1 也是驱动 PWM 9 和 10 号引脚的定时器。所以当你使用了ROS，就不能把 PWM 9,10做模拟输出。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_timer1</span>() {
  <span style="color:#75715e">// Set prescaler 256
</span><span style="color:#75715e"></span>  TCCR1B <span style="color:#f92672">=</span> _BV(CS12) <span style="color:#f92672">|</span> _BV(WGM12);
  <span style="color:#75715e">// For Arduino Uno CPU 16000000 HZ, so the OCR1A should count from 0 to 624
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// x * 1/16M * 256 = 10 ms = 0.01 s
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// x = 16 M / 100 / 256 = 625
</span><span style="color:#75715e"></span>  OCR1A <span style="color:#f92672">=</span> (F_CPU <span style="color:#f92672">/</span> <span style="color:#ae81ff">256</span> <span style="color:#f92672">/</span> ROS_SYS_TICK) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#75715e">// enable compare match 1A interrupt
</span><span style="color:#75715e"></span>  TIMSK1 <span style="color:#f92672">=</span> _BV(OCIE1A);
}
</code></pre></div><p>首先对 Timer1 进行 256 的预分频，我们设置ROS_SYS_TICK为100，表示每秒钟发出100次 System tick，即每次 tick 间隔 10 ms。我们设置Timer1的运行模式为CTC模式（Clear TImer on COmpare Match），所以每当达到这个计数值时，产生一次中断，并重新开始计数。</p>
<p>计算公式： x * 1/16M * 256 = 10 ms = 0.01 s，计算得到 x=625，因为OCR1A是从 0 开始计数的，我们把OCR1A的值设定为 625 - 1 = 624。这样配置 Timer1，就可以让它每 10 ms 产生一次中断，符合我们的System tick。</p>
<p>最后，打开“compare match 1A” 这个中断，将TIMSK1 的 OCIE1A 位 置1 即可。_BV(bit) 是一个宏定义：(1 &laquo; (bit))。</p>
<h4 id="创建默认任务">创建默认任务</h4>
<p>系统初始化时，创建一个idle任务，保证系统在任何时候都有一个任务在运行。Idle任务的优先级最低，为255。</p>
<p>同时idle任务利用了Atmega328p的省电功能，在默认任务中调用睡眠模式以节省能耗。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * @brief The idle task takes advantage of atmega328p&#39;s sleep mode, sleep when
</span><span style="color:#75715e"> * there is no task to run
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_idle_task</span>() {
  set_sleep_mode(SLEEP_MODE_IDLE);
  <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    sleep_mode();
  }
}
</code></pre></div><h3 id="上下文是什么">上下文是什么？</h3>
<p>在开始初始化任务的“上下文”之前，我们先介绍一下在ROS中上下文指的是什么。</p>
<p>ROS 为每个任务都单独分配一个栈，而程序（函数）是运行在栈上的，那么它的上下就是栈了。</p>
<p>栈上都有些什么？函数运行过程中，比如我们想要相加两个数，首先这两个数会被存放在寄存器上，然后 CPU 对他们进行计算，再将结果保存在寄存器中。函数的运行实际上就是内存（栈）、寄存器、CPU三者的交互。</p>
<p>如果我们要打断一个函数的运行，而去运行另一个函数（将系统栈指针指向另一个函数的入口）。因为另一个函数也要使用寄存器，所以我们需要在栈上保存寄存器中的值。</p>
<h3 id="初始化上下文">初始化上下文</h3>
<p>栈空间由用户分配和定义，栈就是一片连续的内存空间，所以可以用数组来存储。函数在栈中运行，PUSH 和 POP 指令也作用于栈。如图 3所示，因为在系统中栈是从内存地址高的位置增长到内存地址低的位置，也就是说 PUSH 指令将递减栈指针，POP指令则递增栈指针。所以在初始化栈的时候，我们传入的是<strong>数组末端的地址</strong>，这样在 PUSH 和 POP 的时候才不会越界。</p>
<p><img src="/images/stack-1558505496131.png" alt="图3 栈和数组"></p>
<p>需要保存的寄存器也是有讲究的，因为我们用 C 写代码，所以这和 C 编译器有关，不同的编译器规则也不同。ROS 主要针对 AVR 平台，使用avr-gcc作为 C 编译器。</p>
<p>avr-gcc 的 <a href="https://gcc.gnu.org/wiki/avr-gcc#Call-Used_Registers">wiki</a> 中有一些规则：</p>
<p>R18-R27，R30，R31，R0，SREG 状态寄存器的T-Flag 都是 Called-Used Register。所谓Called-Used Register在调用函数进入和结束的时候，GCC会生成保存和恢复这些寄存器的指令（PUSH 和POP）。<strong>对于ISR，在进入和退出时会保存和恢复这些寄存器。</strong></p>
<p>R2-R17，R28，R29，R1 是Called-Saved Register。如果函数使用了这些寄存器，那么调用者需要负责保存和恢复这些寄存器。所以我们需要手动保存的寄存器就是Called-Saved Register。而 R1是 Fixed Register，GCC也会保存和恢复。</p>
<p>因此在创建一个新任务时，初始化它的栈：留下空间给R2-R17，R28-R29，并赋值为0。因此栈的大小至少为 18 bytes。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_task_context_init</span>(ROS_TCB <span style="color:#f92672">*</span>tcb_ptr, task_func task_f, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>sp) {
  uint8_t <span style="color:#f92672">*</span>stack_top <span style="color:#f92672">=</span> (uint8_t <span style="color:#f92672">*</span>)sp;
  <span style="color:#75715e">// pc
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// the function pointer is uint16_t in avr
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> (uint8_t)((uint16_t)task_shell <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFF</span>);         <span style="color:#75715e">// the LSB
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> (uint8_t)(((uint16_t)task_shell <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFF</span>);  <span style="color:#75715e">// THE MSB
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Make space for R2-R17, R28-R29
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R2
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R3
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R4
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R5
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R6
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R7
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R8
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R9
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R10
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R11
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R12
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R13
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R14
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R15
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R16
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R17
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R28
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>stack_top<span style="color:#f92672">--</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00</span>; <span style="color:#75715e">// R29
</span><span style="color:#75715e"></span>  tcb_ptr<span style="color:#f92672">-&gt;</span>sp <span style="color:#f92672">=</span> stack_top;
}
</code></pre></div><p>需要注意的是，我们在栈上最先PUSH的是task_shell的函数指针，而函数指针在AVR中一般为 16 位，所以需要两个字节，分别存储它的低8位和高8位。使用task_shell，而不直接用任务的task_entry意图很明显：我们可以在task_shell中标记结束的任务，因为ROS是支持run-to-completion的任务的；同时也可以支持传递任务函数的参数，虽然ROS的任务没有参数，但也有考虑到未来系统的扩展。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * @brief Wrapper of task function, which can pass param to task(for furture
</span><span style="color:#75715e"> * usage), and terminated it and re-schedule when a task run to compeletion
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">task_shell</span>() {
  ROS_TCB <span style="color:#f92672">*</span>cur_tcb <span style="color:#f92672">=</span> ros_current_tcb();

  <span style="color:#75715e">// enable interrupt after context switching finished.
</span><span style="color:#75715e"></span>  sei();

  <span style="color:#66d9ef">if</span> (cur_tcb <span style="color:#f92672">&amp;&amp;</span> cur_tcb<span style="color:#f92672">-&gt;</span>task_entry) {
    cur_tcb<span style="color:#f92672">-&gt;</span>task_entry();
    <span style="color:#75715e">// when the task terminated(task return), remove it from ready list and
</span><span style="color:#75715e"></span>    cur_tcb<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> TASK_TERMINATED;
  }
  <span style="color:#75715e">// re-schedule
</span><span style="color:#75715e"></span>  ros_schedule();
}
</code></pre></div><h2 id="任务调度算法">任务调度算法</h2>
<p>ROS采用preemtive priority-based和Round-robin的调度算法，代码中有三个地方会调用scheduler：</p>
<ul>
<li>
<p>Timer ISR 中周期性调用 scheduler</p>
</li>
<li>
<p>任务主动调用 ros_delay,阻塞自己</p>
</li>
<li>
<p>run-to-completion的任务，在任务结束后需要调用scheduler</p>
</li>
</ul>
<h3 id="isr">ISR</h3>
<p>当中断发生时，系统会调用ISR（Interrupt Service Routine）函数来处理中断。Scheduler的实现依赖于Timer的周期性中断和ISR，因此中断是实现Multitask的基础。每个中断名称都定义在中断向量表中，编写ISR函数的基本格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ISR(interrupt_name_in_vect) {
 <span style="color:#75715e">//your code
</span><span style="color:#75715e"></span>}
</code></pre></div><p>AVR平台在进入ISR时会默认关闭中断。但是对于支持嵌套中断的平台，如果我们在嵌套的ISR中进行上下文切换，可能会破坏队列的结构，使得任务的运行顺序和期望的不同，这就和多线程中的与时间相关的错误类似。我们需要一种机制来让在所有的嵌套ISR快结束时才调用scheduler。通过一个计数就可以解决这个问题：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_int_enter</span>() { ros_int_cnt<span style="color:#f92672">++</span>; }
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_int_exit</span>() {
	ros_int_cnt<span style="color:#f92672">--</span>;
	ros_schedule();
}
</code></pre></div><p>如果 ros_int_cnt 不为 0，则当前处于ISR context中，为0时处于 task context。在 task context 中可以安全的进行任务调度。而这里我们需要处理的中断为Timer1的“compare match 1A”中断。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// interrupt every SYS_TICK to re-schedule tasks
</span><span style="color:#75715e"></span>ISR(TIMER1_COMPA_vect) {
  ros_int_enter();
  ros_sys_tick();
  <span style="color:#75715e">// exit ISR, ready to call scheduler
</span><span style="color:#75715e"></span>  ros_int_exit();
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_schedule</span>() {
	<span style="color:#66d9ef">if</span> (ros_int_cnt <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>ROS_STARTED) <span style="color:#66d9ef">return</span>
	<span style="color:#75715e">// core scheduler code
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="队列操作">队列操作</h3>
<p>对于队列的操作只有两个：入队和出队。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_tcb_enqueue</span>(ROS_TCB <span style="color:#f92672">*</span>tcb);
ROS_TCB <span style="color:#f92672">*</span><span style="color:#a6e22e">ros_tcb_dequeue</span>(uint8_t lowest_priority);
</code></pre></div><p>维护一个优先队列，使用排序链表实现。入队操作的时间复杂度为O(N)，因为入队时需要把TCB按优先级按序插入；而出队最高优先级的任务时间复杂度为O(1)。Round-robin（轮转调度）算法的实现也体现在入队操作中。对于相同优先级的任务，该任务会入队到其他相同优先级任务的尾部：next_ptr-&gt;priority &gt; tcb-&gt;priority，配合系统的周期性中断，实现相同优先级的任务按时间片轮转调度。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * @brief enqueue tcb to list order by priority. Do round-robin when priority is
</span><span style="color:#75715e"> * same.
</span><span style="color:#75715e"> * @param  *tcb: the tcb to insert
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_tcb_enqueue</span>(ROS_TCB <span style="color:#f92672">*</span>tcb) {
  <span style="color:#66d9ef">if</span> (tcb <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
  ROS_TCB <span style="color:#f92672">*</span>prev_ptr, <span style="color:#f92672">*</span>next_ptr;
  prev_ptr <span style="color:#f92672">=</span> next_ptr <span style="color:#f92672">=</span> tcb_ready_list;
  <span style="color:#66d9ef">do</span> {
    <span style="color:#75715e">// Insert when:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// next == NULL
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// next tcb&#39;s priority is lower than than the one we enqueuing
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// same priority task will do round-bobin
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((next_ptr <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">||</span> (next_ptr<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">&gt;</span> tcb<span style="color:#f92672">-&gt;</span>priority)) {
      <span style="color:#75715e">// list is empty or insert to head
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (next_ptr <span style="color:#f92672">==</span> tcb_ready_list) {
        tcb_ready_list <span style="color:#f92672">=</span> tcb;
        tcb<span style="color:#f92672">-&gt;</span>next_tcb <span style="color:#f92672">=</span> next_ptr;  <span style="color:#75715e">// next_ptr maybe NULL
</span><span style="color:#75715e"></span>      } <span style="color:#66d9ef">else</span> {                     <span style="color:#75715e">// insert between tow tcb or tail
</span><span style="color:#75715e"></span>        tcb<span style="color:#f92672">-&gt;</span>next_tcb <span style="color:#f92672">=</span> next_ptr;  <span style="color:#75715e">// next_ptr maybe NUL
</span><span style="color:#75715e"></span>        prev_ptr<span style="color:#f92672">-&gt;</span>next_tcb <span style="color:#f92672">=</span> tcb;
      }
      <span style="color:#66d9ef">break</span>;
    } <span style="color:#66d9ef">else</span> {
      prev_ptr <span style="color:#f92672">=</span> next_ptr;
      next_ptr <span style="color:#f92672">=</span> next_ptr<span style="color:#f92672">-&gt;</span>next_tcb;
    }
  } <span style="color:#66d9ef">while</span> (prev_ptr <span style="color:#f92672">!=</span> NULL);
}
</code></pre></div><p>出队操作则只需要检查队首的TCB，因为队列是有序的，所以队首的TCB总是优先级最高的，如果队首不满足条件，那么接下来的TCB更不会满足。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * @brief  dequeue a tcb to swap in, requeir its priority no lower than
</span><span style="color:#75715e"> * lowest_priority Because the list ordered by priority, we just check the head,
</span><span style="color:#75715e"> * if the head is lower than lowest_priority, return NULL. use
</span><span style="color:#75715e"> * ros_tcb_dequeue(MIN_TASK_PRIORITY) to dequeue head unconditionally
</span><span style="color:#75715e"> * @param lowest_priority: the lowest priority of dequeue tcb or NULL if no such
</span><span style="color:#75715e"> * tcb
</span><span style="color:#75715e"> */</span>
ROS_TCB <span style="color:#f92672">*</span><span style="color:#a6e22e">ros_tcb_dequeue</span>(uint8_t lowest_priority) {
  <span style="color:#66d9ef">if</span> (tcb_ready_list <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> tcb_ready_list<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">&gt;</span> lowest_priority) {
    <span style="color:#66d9ef">return</span> NULL;
  } <span style="color:#66d9ef">else</span> {
    ROS_TCB <span style="color:#f92672">*</span>tcb <span style="color:#f92672">=</span> tcb_ready_list;
    tcb_ready_list <span style="color:#f92672">=</span> tcb_ready_list<span style="color:#f92672">-&gt;</span>next_tcb;
    <span style="color:#66d9ef">if</span> (tcb_ready_list) {
      <span style="color:#75715e">// make return tcb isolated
</span><span style="color:#75715e"></span>      tcb<span style="color:#f92672">-&gt;</span>next_tcb <span style="color:#f92672">=</span> NULL;
    }
    <span style="color:#66d9ef">return</span> tcb;
  }
}
</code></pre></div><h3 id="ros_schedule">ros_schedule</h3>
<p>ros_scheduler函数实现了调度器的主要逻辑：</p>
<p>如果当然在 ISR 中，则直接返回。否则，关闭中断，进入临界区。</p>
<p>如果当前的任务已经结束（run to compeletion）或者被阻塞（任务主动让出 CPU），则无条件调进下一个优先级最高的任务。</p>
<p>否则，从链表中dequeue 一个 new_tcb，如果任务已经终结，则删除任务继续dequeue，直到一个任务符合要求或者为NULL。</p>
<p>如果new_tcb不为 NULL， enqueue当前的任务，调用switch_context。</p>
<p>Scheduler依赖于两个队列操作，操作队列时需要关中断。一个基于优先级的抢占式调度器基本实现，同时还支持删除 run to complete 的任务。详细的代码和逻辑描述如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_schedule</span>() {
  <span style="color:#75715e">// no schedule and context switch util the very end of ISR
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (ros_int_cnt <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>ROS_STARTED) <span style="color:#66d9ef">return</span>;
  CRITICAL_STORE;
  ROS_TCB <span style="color:#f92672">*</span>new_tcb <span style="color:#f92672">=</span> NULL;
  CRITICAL_START();
  <span style="color:#75715e">// if current task is NULL or suspend or terminated, a new task will swap in
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// unconditionally
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (current_tcb <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> current_tcb<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">==</span> TASK_BLOCKED <span style="color:#f92672">||</span>
      current_tcb<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">==</span> TASK_TERMINATED) {
    <span style="color:#75715e">// task with any priority(0~255) can be swap in
</span><span style="color:#75715e"></span>    new_tcb <span style="color:#f92672">=</span> ros_tcb_dequeue(MIN_TASK_PRIORITY);
    <span style="color:#66d9ef">if</span> (new_tcb) {
      <span style="color:#75715e">// Do not enqueue curren_tcb here, when the task is blocked, it is added
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// to timer_queue, it will enqueue when the ticks due.
</span><span style="color:#75715e"></span>      ros_switch_context_shell(current_tcb, new_tcb);
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#75715e">// but you can&#39;t block the idle task
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (current_tcb <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>idle_tcb) current_tcb<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> TASK_READY;
    }
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#75715e">// remove terminated task
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">do</span> {
      new_tcb <span style="color:#f92672">=</span> ros_tcb_dequeue(current_tcb<span style="color:#f92672">-&gt;</span>priority);
    } <span style="color:#66d9ef">while</span> (new_tcb <span style="color:#f92672">&amp;&amp;</span> new_tcb<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">==</span> TASK_TERMINATED);
    <span style="color:#66d9ef">if</span> (new_tcb) {
      ros_tcb_enqueue(current_tcb);
      ros_switch_context_shell(current_tcb, new_tcb);
    }
  }
  CRITICAL_END();
}
</code></pre></div><h3 id="上下文切换">上下文切换</h3>
<p>如 初始化上下文 所述，我们在初始化时为Call-Saved Registers（R1，R2-R17,R28,R29） 预留了空间来保存和恢复他们。上下文切换的代码需要用汇编代码编写，因为需要操作指定的寄存器。方便起见，我直接使用 inline assembly 将汇编代码嵌入到 C 函数中，使用的是Intel风格的汇编，source总是在右边。</p>
<p>上下文切换的步骤可以分为四步，如图 4所示：</p>
<ol>
<li>
<p>保存当前任务的上下文</p>
</li>
<li>
<p>更新当前任务的栈指针（保存系统栈指针到old_tcb-&gt;sp中）</p>
</li>
<li>
<p>将系统栈指针指向新任务的栈指针（将 new_tcb-&gt;sp 赋值给系统栈指针）</p>
</li>
<li>
<p>恢复新任务的上下文（因为我们现在已经在新任务的栈上）</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ros_switch_context</span>(ROS_TCB <span style="color:#f92672">*</span>old_tcb, ROS_TCB <span style="color:#f92672">*</span>new_tcb) {
  <span style="color:#75715e">// The assembly code is in intel style, source is always on the right
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Y-reg is R28 and R29
</span><span style="color:#75715e"></span>  __asm__ __volatile__(
      <span style="color:#e6db74">&#34;push r2</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r3</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r4</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r5</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r6</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r7</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r8</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r9</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r10</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r11</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r12</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r13</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r14</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r15</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r16</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r17</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r28</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;push r29</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#75715e">// r16, r17, r28 and r29 is saved, we&#39;re safe to use them
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;mov r28, %A[_old_tcb_]</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e">// move old tcb(LSB) to Y-regs
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;mov r29, %B[_old_tcb_]</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#75715e">// MSB
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;sbiw r28, 0</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>        <span style="color:#75715e">// subract 0 from r29:r28, we need this to set SREG-Z if result is zero
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;breq restore</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>           <span style="color:#75715e">// if old_tcb is NULL, jump to restore
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;in r16, %[_SPL_]</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>       <span style="color:#75715e">// get stack pointer to r17:r16
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;in r17, %[_SPH_]</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;st Y, r16</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>              <span style="color:#75715e">// set old_tcb-&gt;sp to stack pointer
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;std Y+1, r17</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>           <span style="color:#75715e">// because sp is the first member of the TCB struct
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;restore:&#34;</span>
      <span style="color:#e6db74">&#34;mov r28, %A[_new_tcb_]</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;mov r29, %B[_new_tcb_]</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;ld r16, Y</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>              <span style="color:#75715e">//load new_tcb-&gt;sp to r17:r16
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;ldd r17, Y+1</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;out %[_SPL_], r16</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>      <span style="color:#75715e">//change the stack pointer to new_tcb-&gt;sp
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;out %[_SPH_], r17</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r29</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>                <span style="color:#75715e">// restore new_tcb&#39;s context
</span><span style="color:#75715e"></span>      <span style="color:#e6db74">&#34;pop r28</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r17</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r16</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r15</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r14</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r13</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r12</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r11</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r10</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r9</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r8</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r7</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r6</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r5</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r4</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r3</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;pop r2</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;ret</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
      <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">::</span>
      [_SPL_] <span style="color:#e6db74">&#34;i&#34;</span> _SFR_IO_ADDR(SPL),
      [_SPH_] <span style="color:#e6db74">&#34;i&#34;</span> _SFR_IO_ADDR(SPH),
      [_old_tcb_] <span style="color:#e6db74">&#34;r&#34;</span>(old_tcb),
      [_new_tcb_] <span style="color:#e6db74">&#34;r&#34;</span> (new_tcb)
  );
}
</code></pre></div><p>保存和恢复寄存器的值分别使用 PUSH 和POP 指令。</p>
<p>在更新当前任务的栈指针时，如果是第一个进行任务调度，那么old_tcb会是 NULL，所以我用了sbiw 和 breq 指令进行判断和跳转。使用 sbiw 从 Y 寄存器中减去0，这样Y寄存器中的值不变，但是如果结果为0的话，就说明Y寄存器是NULL，即old_tcb是NULL。那么SREG的Z标记会被置0。而breq指令会在Z标记置零时，进行跳转。</p>
<p>获取和更新系统栈指针（ _SFR_IO_ADDR(SPL) 和 _SFR_IO_ADDR(SPH)）时，同样的，因为栈指针有16位，所以需要两个寄存器来保存它的值。又因系统栈指针在IO地址空间内，所以要用in和out指令来获取和更新。</p>
<p>st指令用来把数据从寄存器存回内存，ld则是把内存地址上的数据加载到寄存器。因为我们的old_tcb和new_tcb都是指针（即内存地址），所以要用st和ld指令来读写任务的栈指针。</p>
<p>图 4为从 task1 切换到 task2 的栈示意图：</p>
<p><img src="/images/switch-context.png" alt="图4 switch context"></p>
<h2 id="ros_delay">ros_delay</h2>
<p>到此，我们已经完成了scheduler的核心功能，ROS已经具备运行多任务的能力，但是现在还不能运行多个任务。如果一个高优先级的任务存在，那么其他低优先级的任务永远不会运行，这种行为对于抢占式调度器是正确的。如图 2ROS的任务四态模型 所示，如果一个方法让高优先级的任务阻塞，那么低优先级的任务才可能调入。</p>
<p>阻塞和唤醒任务的思路如下：</p>
<p>ROS 默认 system tick 为每 10 ms 一次，所以可以 delay 的精度也只能精确到 10。<code>ros_delay()</code>的原理就是利用<code>timer</code>产生的周期性中断。</p>
<ol>
<li><code>ros_delay()</code>设置 tcb 的状态为<code>TASK_BLOCKED</code>，并调用 scheduler，则会无条件的调入下一个任务；</li>
<li>而当前的任务则保存在<code>timer_queue</code>中，每次 system tick，在 ISR 中递减需要延迟的 tick 数；</li>
<li>从<code>timer_queue</code>中遍历出 tick 等于 0 的任务，更新任务状态为<code>TASK_READY</code>，并重新<code>enqueue</code>。</li>
</ol>
<p>阻塞任务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// delay current tcb
</span><span style="color:#75715e"></span>status_t <span style="color:#a6e22e">ros_delay</span>(uint32_t ticks) {
  ROS_TIMER timer;
  ROS_TCB <span style="color:#f92672">*</span>cur_tcb;
  uint8_t status;
  CRITICAL_STORE;
  cur_tcb <span style="color:#f92672">=</span> ros_current_tcb();
  <span style="color:#66d9ef">if</span> (ticks <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
    status <span style="color:#f92672">=</span> ROS_ERR_PARAM;
  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cur_tcb <span style="color:#f92672">==</span> NULL) {
    status <span style="color:#f92672">=</span> ROS_ERR_CONTEXT;
  } <span style="color:#66d9ef">else</span> {
    CRITICAL_START();
    cur_tcb<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> TASK_BLOCKED;
    timer.ticks <span style="color:#f92672">=</span> ticks;
    timer.blocked_tcb <span style="color:#f92672">=</span> cur_tcb;
    <span style="color:#66d9ef">if</span> (ros_register_timer(<span style="color:#f92672">&amp;</span>timer) <span style="color:#f92672">!=</span> ROS_OK) {
      status <span style="color:#f92672">=</span> ROS_ERR_TIMER;
      CRITICAL_END();
    } <span style="color:#66d9ef">else</span> {
      status <span style="color:#f92672">=</span> ROS_OK;
      CRITICAL_END();
      <span style="color:#75715e">// call scheduler to swap out current task
</span><span style="color:#75715e"></span>      ros_schedule();
    }
  }
  <span style="color:#66d9ef">return</span> status;
}
</code></pre></div><p>唤醒任务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wakeup_task</span>(ROS_TCB <span style="color:#f92672">*</span>tcb) {
  CRITICAL_STORE;
  CRITICAL_START();
  tcb<span style="color:#f92672">-&gt;</span>status <span style="color:#f92672">=</span> TASK_READY;
  ros_tcb_enqueue(tcb);
  CRITICAL_END();
}
</code></pre></div><h2 id="构建">构建</h2>
<p>我使用make来构建ROS。对于一个比较大的C项目，如果每次做一点修改，都要去一个个编译，链接，而且编译和链接是有顺序的，每次如此就很繁琐。</p>
<p>使用make，编写Makefile来构建整个项目，只要编写一次Makefile，接下来就可以实现自动构建。Makefile的基本格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile"><span style="color:#75715e"># comment
</span><span style="color:#75715e"># (note: the &lt;tab&gt; in the command line is necessary for make to work)
</span><span style="color:#75715e"></span><span style="color:#a6e22e">target</span><span style="color:#f92672">:</span>  dependency1 dependency2 ...
      &lt;tab&gt; command
</code></pre></div><p>一个构建的目标分为依赖和命令。下面贴上ROS的Makefile：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile">CC<span style="color:#f92672">=</span>avr-gcc
OBJCOPY<span style="color:#f92672">=</span>avr-objcopy
SIZE<span style="color:#f92672">=</span>avr-size
DUDE<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>ARDUINO_DIR<span style="color:#66d9ef">)</span>/hardware/tools/avr/bin/avrdude
SIMAVR<span style="color:#f92672">=</span>simavr

MCU<span style="color:#f92672">=</span>atmega328p
FCPU<span style="color:#f92672">=</span>16000000L

ARDUINO_DIR<span style="color:#f92672">=</span>/home/leer/program/arduino-1.8.9
DUDE_CONF<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>ARDUINO_DIR<span style="color:#66d9ef">)</span>/hardware/tools/avr/etc/avrdude.conf
BUILD_DIR<span style="color:#f92672">=</span>build

CFLAGS<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>INCLUDES<span style="color:#66d9ef">)</span> -g -Wall -Werror -Os -mmcu<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>MCU<span style="color:#66d9ef">)</span> -DF_CPU<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>FCPU<span style="color:#66d9ef">)</span> -DARDUINO<span style="color:#f92672">=</span><span style="color:#ae81ff">10809</span> -DARDUINO_AVR_UNO -DARDUINO_ARCH_AVR

TARGET<span style="color:#f92672">=</span>ros
SOURCE<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>wildcard *.c<span style="color:#66d9ef">)</span>
<span style="color:#75715e"># *.c -&gt; build/*.o
</span><span style="color:#75715e"></span>OBJS<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>addprefix <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/,<span style="color:#66d9ef">$(</span>SOURCE:.c<span style="color:#f92672">=</span>.o<span style="color:#66d9ef">))</span>

<span style="color:#a6e22e">all</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>TARGET<span style="color:#66d9ef">)</span>.hex

<span style="color:#a6e22e">$(BUILD_DIR)/%.o</span><span style="color:#f92672">:</span> %.c
  <span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>CFLAGS<span style="color:#66d9ef">)</span> <span style="color:#960050;background-color:#1e0010">-c</span> <span style="color:#66d9ef">$&lt;</span> <span style="color:#960050;background-color:#1e0010">-o</span> <span style="color:#66d9ef">$@</span>

<span style="color:#a6e22e">$(BUILD_DIR)</span><span style="color:#f92672">:</span>
  <span style="color:#960050;background-color:#1e0010">mkdir</span> <span style="color:#960050;background-color:#1e0010">-p</span> <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>

<span style="color:#75715e"># Build elf, depends on *.o
</span><span style="color:#75715e"></span><span style="color:#a6e22e">$(BUILD_DIR)/$(TARGET).elf</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>OBJS<span style="color:#66d9ef">)</span>
  <span style="color:#960050;background-color:#1e0010">@echo</span> <span style="color:#960050;background-color:#1e0010">Building</span> <span style="color:#66d9ef">$@</span><span style="color:#960050;background-color:#1e0010">...</span>
  <span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>CFLAGS<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>OBJS<span style="color:#66d9ef">)</span> <span style="color:#960050;background-color:#1e0010">-o</span> <span style="color:#66d9ef">$@</span>
  <span style="color:#66d9ef">$(</span>SIZE<span style="color:#66d9ef">)</span> <span style="color:#960050;background-color:#1e0010">-C</span> --mcu<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>MCU<span style="color:#66d9ef">)</span> $@

<span style="color:#75715e"># Build hex, depends on elf
</span><span style="color:#75715e"></span><span style="color:#a6e22e">$(BUILD_DIR)/$(TARGET).hex</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>TARGET<span style="color:#66d9ef">)</span>.elf
  <span style="color:#960050;background-color:#1e0010">@echo</span> <span style="color:#960050;background-color:#1e0010">Building</span> <span style="color:#66d9ef">$@</span><span style="color:#960050;background-color:#1e0010">...</span>
  <span style="color:#66d9ef">$(</span>OBJCOPY<span style="color:#66d9ef">)</span> <span style="color:#960050;background-color:#1e0010">-j</span> <span style="color:#960050;background-color:#1e0010">.text</span> <span style="color:#960050;background-color:#1e0010">-j</span> <span style="color:#960050;background-color:#1e0010">.data</span> <span style="color:#960050;background-color:#1e0010">-O</span> <span style="color:#960050;background-color:#1e0010">ihex</span> <span style="color:#66d9ef">$&lt;</span> <span style="color:#66d9ef">$@</span>

<span style="color:#a6e22e">upload</span><span style="color:#f92672">:</span>
  <span style="color:#960050;background-color:#1e0010">@echo</span> <span style="color:#960050;background-color:#1e0010">Upload</span> <span style="color:#960050;background-color:#1e0010">ROS</span> <span style="color:#960050;background-color:#1e0010">to</span> <span style="color:#960050;background-color:#1e0010">board...</span>
  <span style="color:#a6e22e">$(DUDE) -C $(DUDE_CONF) -v -p $(MCU) -c arduino -P /dev/ttyACM0 -b 115200 -D -U flash</span><span style="color:#f92672">:</span>w:<span style="color:#66d9ef">$(</span>BUILD_DIR<span style="color:#66d9ef">)</span>/<span style="color:#66d9ef">$(</span>TARGET<span style="color:#66d9ef">)</span>.hex:i
<span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> clean
<span style="color:#a6e22e">clean</span><span style="color:#f92672">:</span>
  <span style="color:#960050;background-color:#1e0010">rm</span> <span style="color:#960050;background-color:#1e0010">-rf</span> <span style="color:#960050;background-color:#1e0010">build</span>
</code></pre></div><p>其中的默认目标 all 将构建 <code>$(BUILD_DIR)/$(TARGET).hex</code> 而其依赖于<code>$(BUILD_DIR)/$(TARGET).elf</code>，而它又依赖于 OBJS，所以最终的构建顺序为：</p>
<p><code>OBJS -&gt; $(BUILD_DIR)/$(TARGET).elf -&gt; $(BUILD_DIR)/$(TARGET).hex</code></p>
<p>Upload 将构建好的 hex 文件通过 avrdude 工具上传到 avr开发板上，这里为atmega328p的Arduino Uno。同时也可以自定义 MCU 变量来为不同的开发板构建和上传。</p>
<h2 id="示例">示例</h2>
<p>下面的代码是使用ROS来以不同的频率闪烁两个LED的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Blink example in ROS, DO NOT use any function in Arduino.h
</span><span style="color:#75715e"> */</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;avr/io.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;ros.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// include for simavr
</span><span style="color:#75715e">// #include &#34;avr_mcu_section.h&#34;
</span><span style="color:#75715e">// AVR_MCU(F_CPU, &#34;atmega328p&#34;);
</span><span style="color:#75715e"></span>ROS_TCB task1;
ROS_TCB task2;
uint8_t task1_stack[ROS_DEFAULT_STACK_SIZE];
uint8_t task2_stack[ROS_DEFAULT_STACK_SIZE];

<span style="color:#75715e">#define LED1 13
</span><span style="color:#75715e">#define LED2 12
</span><span style="color:#75715e">#define bitSet(value, bit) ((value) |= (1UL &lt;&lt; (bit)))
</span><span style="color:#75715e">#define bitClear(value, bit) ((value) &amp;= ~(1UL &lt;&lt; (bit)))
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define TASK1_PRIORITY 1
</span><span style="color:#75715e">#define TASK2_PRIORITY 0  </span><span style="color:#75715e">// max priority
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">t1</span>() {
  <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    <span style="color:#75715e">// set LED1 high
</span><span style="color:#75715e"></span>    bitSet(PORTB, <span style="color:#ae81ff">5</span>);
    ros_delay(<span style="color:#ae81ff">200</span>);
    bitClear(PORTB, <span style="color:#ae81ff">5</span>);
    ros_delay(<span style="color:#ae81ff">200</span>);
  }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">t2</span>() {
  <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    bitSet(PORTB, <span style="color:#ae81ff">4</span>);
    <span style="color:#75715e">// delay a second
</span><span style="color:#75715e"></span>    ros_delay(<span style="color:#ae81ff">100</span>);
    bitClear(PORTB, <span style="color:#ae81ff">4</span>);
    ros_delay(<span style="color:#ae81ff">100</span>);
  }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup</span>() {
  <span style="color:#75715e">// set LED 13 and LED 12 as output
</span><span style="color:#75715e"></span>  bitSet(DDRB, <span style="color:#ae81ff">5</span>);
  bitSet(DDRB, <span style="color:#ae81ff">4</span>);
  <span style="color:#66d9ef">bool</span> os_started <span style="color:#f92672">=</span> ros_init();
  <span style="color:#66d9ef">if</span> (os_started) {
    ros_create_task(<span style="color:#f92672">&amp;</span>task1, t1, TASK1_PRIORITY, task1_stack, ROS_DEFAULT_STACK_SIZE);
    ros_create_task(<span style="color:#f92672">&amp;</span>task2, t2, TASK2_PRIORITY, task2_stack, ROS_DEFAULT_STACK_SIZE);
    ros_schedule();
  }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop</span>() {
  <span style="color:#75715e">// nothing
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  setup();
  <span style="color:#75715e">// never call loop
</span><span style="color:#75715e"></span>  loop();
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>两个任务运行流程如下：</p>
<ol>
<li>系统初始化和创建任务之后，Task1，Task2和默认任务都在就绪队列中，最高优先级的Task2被选中运行，将LED2 点亮，然后遇到ros_delay(100)，Task2将被阻塞1秒。</li>
<li>Task1得以运行，将LED1点亮，然后调用ros_delay(200)，将阻塞两秒。</li>
<li>两个任务都被阻塞，默认任务得以运行。</li>
<li>一秒之后，Task2被唤醒，继续运行，将LED2熄灭，接着Task2又将被阻塞1秒。</li>
<li>两秒之后，这时Task1和Task2都被唤醒，优先级较高的Task2运行，将LED2 点亮，调用ros_delay(100)阻塞。</li>
<li>Task2得以运行，将LED1熄灭，调用ros_delay(200)阻塞。</li>
</ol>
<p>这两个任务就以这样的次序不断运行下去，形成的效果就是LDE1会每隔2秒点亮和熄灭，而LED2则每间隔1秒点亮和熄灭。</p>
<p>当然这只是一个简单基础的例子，使用ROS提供的API和Semaphore、Queue 等任务通讯工具就可以构建复杂的multitask应用。</p>
<h2 id="和freertos比较">和FreeRTOS比较</h2>
<p>在两个方面和FreeRTOS进行比较：比较ROS和FreeRTOS的代码量（不包括注释）；使用FreeRTOS写出和以上示例相同功能的代码，比较它们二进制文件的大小。</p>
<p>对于内存有限的嵌入式系统来说，二进制文件的大小也是一个重要的考虑因素。如 图表 2 所示。FreeRTOS在编译时不包含semaphores、queues、mutexs，只包含了设计任务调度的代码，并且两者编译时使用相同的编译器参数。ROS和FreeRTOS的二进制文件，在数据存储空间相差不大；在程序存储空间ROS占用3484字节，占总空间的10.6%，而FreeRTOS占用8424字节，占总空间的25.7%。</p>
<p>两者在代码量上的比较，FreeRTOS为4722行，ROS为677行。FreeRTOS的代码量是ROS的7倍，这是因为FreeRTOS有很多的功能和为通用性考虑的代码。ROS显得更加简洁，适合小型项目和个人学习。</p>
<p><img src="/images/ros-compare-with-freertos.png" alt="ros-compare-with-freertos"></p>
<h2 id="总结">总结</h2>
<p>ROS拥有一个抢占式的任务调度器，对于优先级相同的任务，使用 round-robin算法。</p>
<p>在实现系统时，架构往往比写代码更加重要，如果一开始的程序设计和思路是错误的，那么接下来做的都是徒劳。架构是为了理清思路，而不去纠结细节。ROS的架构和FreeRTOS类似：利用 timer 产生周期性中断，在ISR中调用 scheduler，选择优先级最高的任务（对于相同优先级的任务，使用 round-robin），之后进行上下文切换。同时任务可以主动让出 CPU，让其他低优先级的任务切入。</p>
<p>而花在架构和写代码上的时间也印证了这一点，我用了两星期的时间学习和阅读RTOS的实现思路和代码和其他工具的使用，而写代码用了一个星期的时间。</p>
<p>关于汇编：在写汇编代码的时候，需要时刻保持谨慎。因为写错了真的很难 debug。</p>
<p>关于测试：单元测试在很好用，单独测试每个模块，可以确保这个模块是没有问题的，那么出现错误的时候，我就不会怀疑这个模块，当然也不是绝对的。</p>
<p>在实现ROS的过程中，书上的理论和实际的实现还是有差距的，也发现自己知识的不足（主要是inline assembly 和上下文切换）。也学到了很多关于 AVR 处理器的知识，比如：程序是如何在栈上运行的和上下文切换的具体实现。即使 ROS没有达到生产环境使用的级别，ROS 也让我更加了解实时操作系统的底层实现。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1]Barry, R. FreeRTOS. <a href="https://www.freertos.org/">https://www.freertos.org</a>.</p>
<p>[2]Lawson, K. AtomThreads. <a href="http://atomthreads.com/">http://atomthreads.com</a></p>
<p>[3]（美）DaleWheat著,翁恺译.Arduino技术内幕[M].人民邮电出版社,2013:332.</p>
<p>[4] [美]Michael Margolis.Arduino权威指南(第2版)[M].人民邮电出版社,2015:607.</p>
<p>[5]费翔林,骆斌.操作系统教程(第5版)[M].高等教育出版社,2014:431.</p>
<p>[6]朱迪. FreeRTOS实时操作系统任务调度优化的研究与实现[D].南京邮电大学,2015.</p>
<p>[7]<a href="https://www.microchip.com/webdoc/avrassembler/avrassembler.wb_instruction_list.html">AVR Assembly Instruction</a></p>
<p>[8]<a href="https://gcc.gnu.org/wiki/avr-gcc#Call-Used_Registers">Avr-gcc wiki</a></p>
        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/2019/01/02/os-review-map/">操作系统-复习提纲</a></li>
        
        <li><a href="/2019/01/01/os-banker-algorithm/">操作系统-银行家算法</a></li>
        
        <li><a href="/2018/12/28/os-elevator-algorithm/">操作系统-电梯调度算法</a></li>
        
        <li><a href="/2018/09/29/6.828_hw2_shell/">6.828 Homework 2:Shell</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://leer.moe/tags/rtos'>RTOS</a></li>
                
                <li><a href='https://leer.moe/tags/os'>OS</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
</div>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://leer.moe/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://leer.moe/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>

    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://leer.moe/2020/05/10/crime_and_punishment/" title="罪与罚">罪与罚</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2020/04/10/pandemic/" title="Human, Animal, Pandemic">Human, Animal, Pandemic</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2019/12/26/final-project-codeflow/" title="Final Project">Final Project</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2019/11/29/how2getknowledge/" title="谈谈知识的获取（上）">谈谈知识的获取（上）</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2019/10/26/reclone/" title="强（墙）国下 GitHub 之龟速 git clone">强（墙）国下 GitHub 之龟速 git clone</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2019/09/03/not-afraid/" title="Not Afraid">Not Afraid</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2019/07/13/minesweeper/" title="扫雷游戏中的算法：Union Find 和 Flood Fill">扫雷游戏中的算法：Union Find 和 Flood Fill</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2019/06/25/install_manjaro/" title="Manjaro安装小记&amp;使用体验">Manjaro安装小记&amp;使用体验</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2019/05/12/ros/" title="RTOS设计与实现">RTOS设计与实现</a>
    </li>
    
    <li>
        <a href="https://leer.moe/2019/04/25/java-concurrent-aqs/" title="AbstractQueuedSynchronizer">AbstractQueuedSynchronizer</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li><a href="https://leer.moe/categories/%E5%88%9B%E4%BD%9C%E9%9B%86/">创作集 (19)</a></li>
    
    <li><a href="https://leer.moe/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/">实验室 (10)</a></li>
    
    <li><a href="https://leer.moe/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/">碎碎念 (8)</a></li>
    
    <li><a href="https://leer.moe/categories/%E8%87%AA%E4%B9%A0%E5%AE%A4/">自习室 (35)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://leer.moe/tags/6.828/">6.828</a>
    
    <a href="https://leer.moe/tags/android/">Android</a>
    
    <a href="https://leer.moe/tags/aop/">AOP</a>
    
    <a href="https://leer.moe/tags/c/">C</a>
    
    <a href="https://leer.moe/tags/codelab/">CodeLab</a>
    
    <a href="https://leer.moe/tags/concurrent/">Concurrent</a>
    
    <a href="https://leer.moe/tags/csapp/">CSAPP</a>
    
    <a href="https://leer.moe/tags/deepin/">Deepin</a>
    
    <a href="https://leer.moe/tags/editor/">Editor</a>
    
    <a href="https://leer.moe/tags/firewall/">firewall</a>
    
    <a href="https://leer.moe/tags/flowchart/">Flowchart</a>
    
    <a href="https://leer.moe/tags/git/">git</a>
    
    <a href="https://leer.moe/tags/github/">GitHub</a>
    
    <a href="https://leer.moe/tags/grain/">Grain</a>
    
    <a href="https://leer.moe/tags/hexo/">Hexo</a>
    
    <a href="https://leer.moe/tags/hibernate/">Hibernate</a>
    
    <a href="https://leer.moe/tags/https/">Https</a>
    
    <a href="https://leer.moe/tags/java/">Java</a>
    
    <a href="https://leer.moe/tags/javafx/">JavaFX</a>
    
    <a href="https://leer.moe/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a>
    
    <a href="https://leer.moe/tags/java%E5%B9%B6%E5%8F%91/">Java并发</a>
    
    <a href="https://leer.moe/tags/jvm/">JVM</a>
    
    <a href="https://leer.moe/tags/kotlin/">Kotlin</a>
    
    <a href="https://leer.moe/tags/manjaro/">Manjaro</a>
    
    <a href="https://leer.moe/tags/minecraft/">Minecraft</a>
    
    <a href="https://leer.moe/tags/music/">Music</a>
    
    <a href="https://leer.moe/tags/mybatis/">MyBatis</a>
    
    <a href="https://leer.moe/tags/os/">OS</a>
    
    <a href="https://leer.moe/tags/rtos/">RTOS</a>
    
    <a href="https://leer.moe/tags/semaphore/">Semaphore</a>
    
    <a href="https://leer.moe/tags/shell/">Shell</a>
    
    <a href="https://leer.moe/tags/spring/">Spring</a>
    
    <a href="https://leer.moe/tags/spring-boot/">Spring Boot</a>
    
    <a href="https://leer.moe/tags/telegram/">Telegram</a>
    
    <a href="https://leer.moe/tags/ubuntu/">Ubuntu</a>
    
    <a href="https://leer.moe/tags/v2ray/">V2ray</a>
    
    <a href="https://leer.moe/tags/vip/">VIP</a>
    
    <a href="https://leer.moe/tags/web/">Web</a>
    
    <a href="https://leer.moe/tags/wps/">WPS</a>
    
    <a href="https://leer.moe/tags/%E5%86%99%E4%BD%9C/">写作</a>
    
    <a href="https://leer.moe/tags/%E5%8D%9A%E5%AE%A2%E4%BA%8B%E8%AE%B0/">博客事记</a>
    
    <a href="https://leer.moe/tags/%E5%90%90%E6%A7%BD/">吐槽</a>
    
    <a href="https://leer.moe/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">年终总结</a>
    
    <a href="https://leer.moe/tags/%E5%BE%AE%E4%BF%A1/">微信</a>
    
    <a href="https://leer.moe/tags/%E6%8A%80%E6%9C%AF/">技术</a>
    
    <a href="https://leer.moe/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://leer.moe/tags/%E6%97%A5%E5%B8%B8/">日常</a>
    
    <a href="https://leer.moe/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a>
    
    <a href="https://leer.moe/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/">流程图</a>
    
    <a href="https://leer.moe/tags/%E7%9B%B8%E5%86%8C/">相册</a>
    
    <a href="https://leer.moe/tags/%E7%AE%97%E6%B3%95/">算法</a>
    
    <a href="https://leer.moe/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
    
    <a href="https://leer.moe/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
    
    <a href="https://leer.moe/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="https://leer.moe/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
    
    <a href="https://leer.moe/tags/%E9%9A%8F%E8%AE%B0/">随记</a>
    
    <a href="https://leer.moe/tags/%E9%A5%A5%E8%8D%92/">饥荒</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://leer.moe/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div class="container">
        &copy; 2020 <a href="https://leer.moe/">LeeReindeer&#39;s blog By </a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/flysnow-org/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>






</body>

</html>